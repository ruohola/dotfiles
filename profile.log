SCRIPT  C:\Users\eero.ruohola\vimfiles\plugged\clever-f.vim\autoload\clever_f.vim
Sourced 1 time
Total time:   0.001014
 Self time:   0.001014

count  total (s)   self (s)
    1              0.000009 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000007 let g:clever_f_across_no_line          = get(g:, 'clever_f_across_no_line', 0)
    1              0.000010 let g:clever_f_ignore_case             = get(g:, 'clever_f_ignore_case', 0)
    1              0.000008 let g:clever_f_use_migemo              = get(g:, 'clever_f_use_migemo', 0)
    1              0.000004 let g:clever_f_fix_key_direction       = get(g:, 'clever_f_fix_key_direction', 0)
    1              0.000007 let g:clever_f_show_prompt             = get(g:, 'clever_f_show_prompt', 0)
    1              0.000004 let g:clever_f_smart_case              = get(g:, 'clever_f_smart_case', 0)
    1              0.000005 let g:clever_f_chars_match_any_signs   = get(g:, 'clever_f_chars_match_any_signs', '')
    1              0.000004 let g:clever_f_mark_cursor             = get(g:, 'clever_f_mark_cursor', 1)
    1              0.000004 let g:clever_f_hide_cursor_on_cmdline  = get(g:, 'clever_f_hide_cursor_on_cmdline', 1)
    1              0.000003 let g:clever_f_timeout_ms              = get(g:, 'clever_f_timeout_ms', 0)
    1              0.000004 let g:clever_f_mark_char               = get(g:, 'clever_f_mark_char', 1)
    1              0.000006 let g:clever_f_repeat_last_char_inputs = get(g:, 'clever_f_repeat_last_char_inputs', ["\<CR>"])
                            
                            " below variables must be set before loading this script
    1              0.000005 let g:clever_f_mark_cursor_color       = get(g:, 'clever_f_mark_cursor_color', 'Cursor')
    1              0.000005 let g:clever_f_mark_char_color         = get(g:, 'clever_f_mark_char_color', 'CleverFDefaultLabel')
    1              0.000003 let g:clever_f_clean_labels_eagerly    = get(g:, 'clever_f_clean_labels_eagerly', 1)
                            
                            " highlight labels
    1              0.000002 augroup plugin-clever-f-highlight
    1              0.000027     autocmd!
    1              0.000011     autocmd ColorScheme * highlight default CleverFDefaultLabel ctermfg=red ctermbg=NONE cterm=bold,underline guifg=red guibg=NONE gui=bold,underline
    1              0.000002 augroup END
    1              0.000022 highlight default CleverFDefaultLabel ctermfg=red ctermbg=NONE cterm=bold,underline guifg=red guibg=NONE gui=bold,underline
                            
    1              0.000003 if g:clever_f_mark_cursor
    1              0.000008     execute 'highlight link CleverFCursor' g:clever_f_mark_cursor_color
    1              0.000001 endif
    1              0.000002 if g:clever_f_mark_char
    1              0.000007     execute 'highlight link CleverFChar' g:clever_f_mark_char_color
    1              0.000001 endif
                            
    1              0.000002 if g:clever_f_clean_labels_eagerly
    1              0.000002     augroup plugin-clever-f-permanent-finalizer
    1              0.000020         autocmd!
    1              0.000020         autocmd WinEnter,WinLeave,CmdWinLeave * if g:clever_f_mark_char | call s:remove_highlight() | endif
    1              0.000001     augroup END
    1              0.000001 endif
    1              0.000002 augroup plugin-clever-f-finalizer
    1              0.000017     autocmd!
    1              0.000001 augroup END
                            
                            " initialize the internal state
    1              0.000003 let s:last_mode = ''
    1              0.000003 let s:previous_map = {}
    1              0.000002 let s:previous_pos = {}
    1              0.000002 let s:first_move = {}
    1              0.000002 let s:migemo_dicts = {}
    1              0.000002 let s:previous_char_num = {}
    1              0.000005 let s:timestamp = [0, 0]
                            
                            " keys are mode string returned from mode()
    1              0.000003 function! clever_f#reset() abort
                                let s:previous_map = {}
                                let s:previous_pos = {}
                                let s:first_move = {}
                                let s:migemo_dicts = {}
                            
                                " Note:
                                " [0, 0] may be invalid because the representation of return value of reltime() depends on implementation.
                                let s:timestamp = [0, 0]
                            
                                call s:remove_highlight()
                            
                                return ''
                            endfunction
                            
                            " hidden API for debug
    1              0.000002 function! clever_f#_reset_all() abort
                                call clever_f#reset()
                                let s:last_mode = ''
                                let s:previous_char_num = {}
                                autocmd! plugin-clever-f-finalizer
                                unlet! s:moved_forward
                            
                                return ''
                            endfunction
                            
    1              0.000003 function! s:remove_highlight() abort
                                for h in filter(getmatches(), 'v:val.group ==# "CleverFChar"')
                                    call matchdelete(h.id)
                                endfor
                            endfunction
                            
    1              0.000002 function! s:is_timedout() abort
                                let cur = reltime()
                                let rel = reltimestr(reltime(s:timestamp, cur))
                                let elapsed_ms = float2nr(str2float(rel) * 1000.0)
                                let s:timestamp = cur
                                return elapsed_ms > g:clever_f_timeout_ms
                            endfunction
                            
    1              0.000003 function! s:mark_char_in_current_line(map, char) abort
                                let regex = '\%' . line('.') . 'l' . s:generate_pattern(a:map, a:char)
                                call matchadd('CleverFChar', regex , 999)
                            endfunction
                            
                            " Note:
                            " \x80\xfd` seems to be sent by a terminal.
                            " Below is a workaround for the sequence.
    1              0.000002 function! s:getchar() abort
                                while 1
                                    let cn = getchar()
                                    if type(cn) != type('') || cn !=# "\x80\xfd`"
                                        return cn
                                    endif
                                endwhile
                            endfunction
                            
    1              0.000014 function! s:include_multibyte_char(str) abort
                                return strlen(a:str) != clever_f#compat#strchars(a:str)
                            endfunction
                            
    1              0.000002 function! clever_f#find_with(map) abort
                                if a:map !~# '^[fFtT]$'
                                    echoerr 'Invalid mapping: ' . a:map
                                    return ''
                                endif
                            
                                if &foldopen =~# '\<\%(all\|hor\)\>'
                                    while foldclosed(line('.')) >= 0
                                        foldopen
                                    endwhile
                                endif
                            
                                let current_pos = getpos('.')[1 : 2]
                            
                                let mode = mode(1)
                                if current_pos != get(s:previous_pos, mode, [0, 0])
                                    let back = 0
                                    if g:clever_f_mark_cursor
                                        let cursor_marker = matchadd('CleverFCursor', '\%#', 999)
                                        redraw
                                    endif
                                    if g:clever_f_hide_cursor_on_cmdline
                                        let guicursor_save = &guicursor
                                        set guicursor=n:block-NONE
                                        let t_ve_save = &t_ve
                                        set t_ve=
                                    endif
                                    try
                                        if g:clever_f_show_prompt | echon 'clever-f: ' | endif
                                        let s:previous_map[mode] = a:map
                                        let s:first_move[mode] = 1
                                        let cn = s:getchar()
                                        if cn == char2nr("\<Esc>")
                                            return "\<Esc>"
                                        endif
                                        if index(map(deepcopy(g:clever_f_repeat_last_char_inputs), 'char2nr(v:val)'), cn) == -1
                                            let s:previous_char_num[mode] = cn
                                        else
                                            if has_key(s:previous_char_num, s:last_mode)
                                                let s:previous_char_num[mode] = s:previous_char_num[s:last_mode]
                                            else
                                                echohl ErrorMsg | echo 'Previous input not found.' | echohl None
                                                return ''
                                            endif
                                        endif
                                        let s:last_mode = mode
                            
                                        if g:clever_f_timeout_ms > 0
                                            let s:timestamp = reltime()
                                        endif
                            
                                        if g:clever_f_mark_char
                                            call s:remove_highlight()
                                            if index(['n', 'v', 'V', "\<C-v>", 's', 'ce'], mode) != -1
                                                augroup plugin-clever-f-finalizer
                                                    autocmd CursorMoved <buffer> call s:maybe_finalize()
                                                    autocmd InsertEnter <buffer> call s:finalize()
                                                augroup END
                                                call s:mark_char_in_current_line(s:previous_map[mode], s:previous_char_num[mode])
                                            endif
                                        endif
                            
                                        if g:clever_f_show_prompt | redraw! | endif
                                    finally
                                        if g:clever_f_mark_cursor | call matchdelete(cursor_marker) | endif
                                        if g:clever_f_hide_cursor_on_cmdline
                                            set guicursor&
                                            let &guicursor = guicursor_save
                                            let &t_ve = t_ve_save
                                        endif
                                    endtry
                                else
                                    " when repeated
                                    let back = a:map =~# '\u'
                                    if g:clever_f_fix_key_direction
                                        let back = s:previous_map[mode] =~# '\u' ? !back : back
                                    endif
                            
                                    " reset and retry if timed out
                                    if g:clever_f_timeout_ms > 0 && s:is_timedout()
                                        call clever_f#reset()
                                        return clever_f#find_with(a:map)
                                    endif
                                endif
                            
                                return clever_f#repeat(back)
                            endfunction
                            
    1              0.000002 function! clever_f#repeat(back) abort
                                let mode = mode(1)
                                let pmap = get(s:previous_map, mode, '')
                                let prev_char_num = get(s:previous_char_num, mode, 0)
                            
                                if pmap ==# ''
                                    return ''
                                endif
                            
                                " ignore special characters like \<Left>
                                if type(prev_char_num) == type('') && char2nr(prev_char_num) == 128
                                    return ''
                                endif
                            
                                if a:back
                                    let pmap = s:swapcase(pmap)
                                endif
                            
                                if mode ==? 'v' || mode ==# "\<C-v>"
                                    let cmd = s:move_cmd_for_visualmode(pmap, prev_char_num)
                                else
                                    let inclusive = mode ==# 'no' && pmap =~# '\l'
                                    let cmd = printf("%s:\<C-u>call clever_f#find(%s, %s)\<CR>",
                                                \    inclusive ? 'v' : '',
                                                \    string(pmap), prev_char_num)
                                endif
                            
                                return cmd
                            endfunction
                            
                            " absolutely moved forward?
    1              0.000003 function! s:moves_forward(p, n) abort
                                if a:p[0] != a:n[0]
                                    return a:p[0] < a:n[0]
                                endif
                            
                                if a:p[1] != a:n[1]
                                    return a:p[1] < a:n[1]
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000003 function! clever_f#find(map, char_num) abort
                                let before_pos = getpos('.')[1 : 2]
                                let next_pos = s:next_pos(a:map, a:char_num, v:count1)
                                if next_pos == [0, 0]
                                    return
                                endif
                            
                                let moves_forward = s:moves_forward(before_pos, next_pos)
                            
                                " update highlight when cursor moves across lines
                                let mode = mode(1)
                                if g:clever_f_mark_char
                                    if next_pos[0] != before_pos[0]
                                        \ || (a:map ==? 't' && !s:first_move[mode] && clever_f#compat#xor(s:moved_forward, moves_forward))
                                        call s:remove_highlight()
                                        call s:mark_char_in_current_line(a:map, a:char_num)
                                    endif
                                endif
                            
                                let s:moved_forward = moves_forward
                                let s:previous_pos[mode] = next_pos
                                let s:first_move[mode] = 0
                            endfunction
                            
    1              0.000002 function! s:finalize() abort
                                autocmd! plugin-clever-f-finalizer
                                call s:remove_highlight()
                                let s:moved_forward = 0
                            endfunction
                            
    1              0.000002 function! s:maybe_finalize() abort
                                let pp = get(s:previous_pos, s:last_mode, [0, 0])
                                if getpos('.')[1 : 2] != pp
                                    call s:finalize()
                                endif
                            endfunction
                            
    1              0.000003 function! s:move_cmd_for_visualmode(map, char_num) abort
                                let next_pos = s:next_pos(a:map, a:char_num, v:count1)
                                if next_pos == [0, 0]
                                    return ''
                                endif
                            
                                let m = mode(1)
                                call setpos("''", [0] + next_pos + [0])
                                let s:previous_pos[m] = next_pos
                                let s:first_move[m] = 0
                            
                                return '``'
                            endfunction
                            
    1              0.000002 function! s:search(pat, flag) abort
                                if g:clever_f_across_no_line
                                    return search(a:pat, a:flag, line('.'))
                                else
                                    return search(a:pat, a:flag)
                                endif
                            endfunction
                            
    1              0.000003 function! s:should_use_migemo(char) abort
                                if !g:clever_f_use_migemo || a:char !~# '^\a$'
                                    return 0
                                endif
                            
                                if !g:clever_f_across_no_line
                                    return 1
                                endif
                            
                                return s:include_multibyte_char(getline('.'))
                            endfunction
                            
    1              0.000002 function! s:load_migemo_dict() abort
                                let enc = &l:encoding
                                if enc ==# 'utf-8'
                                    return clever_f#migemo#utf8#load_dict()
                                elseif enc ==# 'cp932'
                                    return clever_f#migemo#cp932#load_dict()
                                elseif enc ==# 'euc-jp'
                                    return clever_f#migemo#eucjp#load_dict()
                                else
                                    let g:clever_f_use_migemo = 0
                                    throw 'Error: ' . enc . ' is not supported. Migemo is disabled.'
                                endif
                            endfunction
                            
    1              0.000003 function! s:generate_pattern(map, char_num) abort
                                let char = type(a:char_num) == type(0) ? nr2char(a:char_num) : a:char_num
                                let regex = char
                            
                                let should_use_migemo = s:should_use_migemo(char)
                                if should_use_migemo
                                    if !has_key(s:migemo_dicts, &l:encoding)
                                        let s:migemo_dicts[&l:encoding] = s:load_migemo_dict()
                                    endif
                                    let regex = s:migemo_dicts[&l:encoding][regex] . '\&\%(' . char . '\|\A\)'
                                elseif stridx(g:clever_f_chars_match_any_signs, char) != -1
                                    let regex = '\[!"#$%&''()=~|\-^\\@`[\]{};:+*<>,.?_/]'
                                elseif char ==# '\'
                                    let regex = '\\'
                                endif
                            
                                let is_exclusive_visual = &selection ==# 'exclusive' && mode(1) ==? 'v'
                                if a:map ==# 't' && !is_exclusive_visual
                                    let regex = '\_.\ze\%(' . regex . '\)'
                                elseif is_exclusive_visual && a:map ==# 'f'
                                    let regex = '\%(' . regex . '\)\zs\_.'
                                elseif a:map ==# 'T'
                                    let regex = '\%(' . regex . '\)\@<=\_.'
                                endif
                            
                                if !should_use_migemo
                                    let regex = '\V'.regex
                                endif
                            
                                return ((g:clever_f_smart_case && char =~# '\l') || g:clever_f_ignore_case ? '\c' : '\C') . regex
                            endfunction
                            
    1              0.000003 function! s:next_pos(map, char_num, count) abort
                                let mode = mode(1)
                                let search_flag = a:map =~# '\l' ? 'W' : 'bW'
                                let cnt = a:count
                                let pattern = s:generate_pattern(a:map, a:char_num)
                            
                                if a:map ==? 't' && get(s:first_move, mode, 1)
                                    if !s:search(pattern, search_flag . 'c')
                                        return [0, 0]
                                    endif
                                    let cnt -= 1
                                endif
                            
                                while 0 < cnt
                                    if !s:search(pattern, search_flag)
                                        return [0, 0]
                                    endif
                                    let cnt -= 1
                                endwhile
                            
                                return getpos('.')[1 : 2]
                            endfunction
                            
    1              0.000003 function! s:swapcase(char) abort
                                return a:char =~# '\u' ? tolower(a:char) : toupper(a:char)
                            endfunction
                            
    1              0.000007 let &cpo = s:save_cpo
    1              0.000008 unlet s:save_cpo

SCRIPT  C:\Users\eero.ruohola\vimfiles\plugged\ale\autoload\ale\path.vim
Sourced 1 time
Total time:   0.004825
 Self time:   0.004779

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Functions for working with paths in the filesystem.
                            
                            " simplify a path, and fix annoying issues with paths on Windows.
                            "
                            " Forward slashes are changed to back slashes so path equality works better.
                            "
                            " Paths starting with more than one forward slash are changed to only one
                            " forward slash, to prevent the paths being treated as special MSYS paths.
    1              0.000008 function! ale#path#Simplify(path) abort
                                if has('unix')
                                    return substitute(simplify(a:path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks
                            endfunction
                            
                            " Given a buffer and a filename, find the nearest file by searching upwards
                            " through the paths relative to the given buffer.
    1              0.000003 function! ale#path#FindNearestFile(buffer, filename) abort
                                let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
                                let l:buffer_filename = fnameescape(l:buffer_filename)
                            
                                let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
                                if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
                                endif
                            
                                return ''
                            endfunction
                            
                            " Given a buffer and a directory name, find the nearest directory by searching upwards
                            " through the paths relative to the given buffer.
    1              0.000003 function! ale#path#FindNearestDirectory(buffer, directory_name) abort
                                let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
                                let l:buffer_filename = fnameescape(l:buffer_filename)
                            
                                let l:relative_path = finddir(a:directory_name, l:buffer_filename . ';')
                            
                                if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
                                endif
                            
                                return ''
                            endfunction
                            
                            " Given a buffer, a string to search for, an a global fallback for when
                            " the search fails, look for a file in parent paths, and if that fails,
                            " use the global fallback path instead.
    1              0.000003 function! ale#path#ResolveLocalPath(buffer, search_string, global_fallback) abort
                                " Search for a locally installed file first.
                                let l:path = ale#path#FindNearestFile(a:buffer, a:search_string)
                            
                                " If the serach fails, try the global executable instead.
                                if empty(l:path)
                                    let l:path = a:global_fallback
                                endif
                            
                                return l:path
                            endfunction
                            
                            " Output 'cd <directory> && '
                            " This function can be used changing the directory for a linter command.
    1              0.000002 function! ale#path#CdString(directory) abort
                                return 'cd ' . ale#Escape(a:directory) . ' && '
                            endfunction
                            
                            " Output 'cd <buffer_filename_directory> && '
                            " This function can be used changing the directory for a linter command.
    1              0.000002 function! ale#path#BufferCdString(buffer) abort
                                return ale#path#CdString(fnamemodify(bufname(a:buffer), ':p:h'))
                            endfunction
                            
                            " Return 1 if a path is an absolute path.
    1              0.000002 function! ale#path#IsAbsolute(filename) abort
                                if has('win32') && a:filename[:0] is# '\'
                                    return 1
                                endif
                            
                                " Check for /foo and C:\foo, etc.
                                return a:filename[:0] is# '/' || a:filename[1:2] is# ':\'
                            endfunction
                            
    1   0.004395   0.004349 let s:temp_dir = ale#path#Simplify(fnamemodify(tempname(), ':h'))
                            
                            " Given a filename, return 1 if the file represents some temporary file
                            " created by Vim.
    1              0.000004 function! ale#path#IsTempName(filename) abort
                                return ale#path#Simplify(a:filename)[:len(s:temp_dir) - 1] is# s:temp_dir
                            endfunction
                            
                            " Given a base directory, which must not have a trailing slash, and a
                            " filename, which may have an absolute path a path relative to the base
                            " directory, return the absolute path to the file.
    1              0.000003 function! ale#path#GetAbsPath(base_directory, filename) abort
                                if ale#path#IsAbsolute(a:filename)
                                    return ale#path#Simplify(a:filename)
                                endif
                            
                                let l:sep = has('win32') ? '\' : '/'
                            
                                return ale#path#Simplify(a:base_directory . l:sep . a:filename)
                            endfunction
                            
                            " Given a buffer number and a relative or absolute path, return 1 if the
                            " two paths represent the same file on disk.
    1              0.000025 function! ale#path#IsBufferPath(buffer, complex_filename) abort
                                " If the path is one of many different names for stdin, we have a match.
                                if a:complex_filename is# '-'
                                \|| a:complex_filename is# 'stdin'
                                \|| a:complex_filename[:0] is# '<'
                                    return 1
                                endif
                            
                                let l:test_filename = ale#path#Simplify(a:complex_filename)
                            
                                if l:test_filename[:1] is# './'
                                    let l:test_filename = l:test_filename[2:]
                                endif
                            
                                if l:test_filename[:1] is# '..'
                                    " Remove ../../ etc. from the front of the path.
                                    let l:test_filename = substitute(l:test_filename, '\v^(\.\.[/\\])+', '/', '')
                                endif
                            
                                " Use the basename for temporary files, as they are likely our files.
                                if ale#path#IsTempName(l:test_filename)
                                    let l:test_filename = fnamemodify(l:test_filename, ':t')
                                endif
                            
                                let l:buffer_filename = expand('#' . a:buffer . ':p')
                            
                                return l:buffer_filename is# l:test_filename
                                \   || l:buffer_filename[-len(l:test_filename):] is# l:test_filename
                            endfunction
                            
                            " Given a path, return every component of the path, moving upwards.
    1              0.000002 function! ale#path#Upwards(path) abort
                                let l:pattern = has('win32') ? '\v/+|\\+' : '\v/+'
                                let l:sep = has('win32') ? '\' : '/'
                                let l:parts = split(ale#path#Simplify(a:path), l:pattern)
                                let l:path_list = []
                            
                                while !empty(l:parts)
                                    call add(l:path_list, join(l:parts, l:sep))
                                    let l:parts = l:parts[:-2]
                                endwhile
                            
                                if has('win32') && a:path =~# '^[a-zA-z]:\'
                                    " Add \ to C: for C:\, etc.
                                    let l:path_list[-1] .= '\'
                                elseif a:path[0] is# '/'
                                    " If the path starts with /, even on Windows, add / and / to all paths.
                                    call map(l:path_list, '''/'' . v:val')
                                    call add(l:path_list, '/')
                                endif
                            
                                return l:path_list
                            endfunction
                            
                            " Convert a filesystem path to a file:// URI
                            " relatives paths will not be prefixed with the protocol.
                            " For Windows paths, the `:` in C:\ etc. will not be percent-encoded.
    1              0.000002 function! ale#path#ToURI(path) abort
                                let l:has_drive_letter = a:path[1:2] is# ':\'
                            
                                return substitute(
                                \   ((l:has_drive_letter || a:path[:0] is# '/') ? 'file://' : '')
                                \       . (l:has_drive_letter ? '/' . a:path[:2] : '')
                                \       . ale#uri#Encode(l:has_drive_letter ? a:path[3:] : a:path),
                                \   '\\',
                                \   '/',
                                \   'g',
                                \)
                            endfunction
                            
    1              0.000002 function! ale#path#FromURI(uri) abort
                                let l:i = len('file://')
                                let l:encoded_path = a:uri[: l:i - 1] is# 'file://' ? a:uri[l:i :] : a:uri
                            
                                let l:path = ale#uri#Decode(l:encoded_path)
                            
                                " If the path is like /C:/foo/bar, it should be C:\foo\bar instead.
                                if l:path =~# '^/[a-zA-Z]:'
                                    let l:path = substitute(l:path[1:], '/', '\\', 'g')
                                endif
                            
                                return l:path
                            endfunction

FUNCTION  <SNR>64_FindHistoryItem()
Called 26 times
Total time:   0.001372
 Self time:   0.000926

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
   26   0.000984   0.000539     for l:obj in reverse(ale#history#Get(a:buffer))
   26              0.000103         if l:obj.job_id == a:job_id
   26              0.000065             return l:obj
                                    endif
                                endfor
                            
                                return {}

FUNCTION  traces#cmdl_leave()
Called 71 times
Total time:   0.001963
 Self time:   0.001871

count  total (s)   self (s)
   71              0.000343   let s:nr = bufnr('%')
   71              0.000370   if !exists('s:buf[s:nr]')
   67              0.000080     return
                              endif
                            
    4   0.000113   0.000027   call s:restore_undo_history()
                            
                              " highlights
    4              0.000018   if exists('s:win[win_getid()]')
    2              0.000003     if &scrolloff !=# 0
    2              0.000004       let scrolloff = &scrolloff
    2              0.000015       noautocmd let &scrolloff = 0
    2              0.000001     endif
    2              0.000005     let cur_win = win_getid()
    2              0.000007     let alt_win = win_getid(winnr('#'))
    2   0.000105   0.000099     let windows = filter(win_findbuf(s:nr), {_, val -> win_id2win(val)})
    4              0.000007     for id in windows
    2              0.000015       let wininfo = getwininfo(id)[0]
    2              0.000005       if wininfo.height is 0 || wininfo.width is 0
                                    " skip minimized windows
                                    continue
                                  endif
    2              0.000011       noautocmd call win_gotoid(id)
    2              0.000007       if exists('s:win[id]')
    2              0.000007         if exists('s:win[id].hlight')
    4              0.000012           for group in keys(s:win[id].hlight)
    2              0.000008             if s:win[id].hlight[group].index !=# - 1
    2              0.000011               silent! call matchdelete(s:win[id].hlight[group].index)
    2              0.000002             endif
    2              0.000002           endfor
    2              0.000002         endif
    2              0.000007         if exists('s:win[id].options')
    6              0.000015           for option in keys(s:win[id].options)
    4              0.000051             execute 'noautocmd let &' . option . '="' . s:win[id].options[option] . '"'
    4              0.000003           endfor
    2              0.000002         endif
    2              0.000009         unlet s:win[id]
    2              0.000001       endif
    2              0.000002     endfor
    2              0.000006     if bufname('%') !=# '[Command Line]'
    2              0.000012       noautocmd call win_gotoid(s:buf[s:nr].alt_win)
    2              0.000009       noautocmd call win_gotoid(cur_win)
    2              0.000002     endif
    2              0.000005     if exists('scrolloff')
    2              0.000012       noautocmd let &scrolloff = scrolloff
    2              0.000002     endif
    2              0.000001   endif
                            
    4              0.000011   if &hlsearch !=# s:buf[s:nr].hlsearch
                                noautocmd let &hlsearch = s:buf[s:nr].hlsearch
                              endif
    4              0.000008   if &cmdheight !=# s:buf[s:nr].cmdheight
                                noautocmd let &cmdheight = s:buf[s:nr].cmdheight
                              endif
    4              0.000008   if &winwidth isnot s:buf[s:nr].winwidth
    2              0.000012     noautocmd let &winwidth = s:buf[s:nr].winwidth
    2              0.000002   endif
    4              0.000008   if &winheight isnot s:buf[s:nr].winheight
                                noautocmd let &winheight = s:buf[s:nr].winheight
                              endif
                            
    4              0.000021   if winrestcmd() isnot s:buf[s:nr].winrestcmd
                                noautocmd execute s:buf[s:nr].winrestcmd
                              endif
    4              0.000025   if winsaveview() !=# s:buf[s:nr].view
    2              0.000084     call winrestview(s:buf[s:nr].view)
    2              0.000002   endif
    4              0.000031   unlet s:buf[s:nr]

FUNCTION  3()
Called 79 times
Total time:   0.000322
 Self time:   0.000322

count  total (s)   self (s)
   79              0.000253     return self.cached_tabline

FUNCTION  <SNR>14_opfunc()
Called 2 times
Total time:   0.028945
 Self time:   0.003688

count  total (s)   self (s)
    2              0.000016   if a:type ==# 'setup'
                                let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w\+$')
                                return 'g@'
                              endif
    2   0.001058   0.000066   let char = s:inputreplacement()
    2              0.000010   if char == ""
                                return s:beep()
                              endif
    2              0.000010   let reg = '"'
    2              0.000015   let sel_save = &selection
    2              0.000036   let &selection = "inclusive"
    2              0.000012   let cb_save  = &clipboard
    2              0.000044   set clipboard-=unnamed clipboard-=unnamedplus
    2              0.000038   let reg_save = getreg(reg)
    2              0.000019   let reg_type = getregtype(reg)
    2              0.000011   let type = a:type
    2              0.000011   if a:type == "char"
                                silent exe 'norm! v`[o`]"'.reg.'y'
                                let type = 'v'
                              elseif a:type == "line"
                                silent exe 'norm! `[V`]"'.reg.'y'
                                let type = 'V'
                              elseif a:type ==# "v" || a:type ==# "V" || a:type ==# "\<C-V>"
    2              0.000023     let &selection = sel_save
    2              0.000010     let ve = &virtualedit
    2              0.000012     if !(a:0 && a:1)
                                  set virtualedit=
                                endif
    2   0.001544   0.001017     silent exe 'norm! gv"'.reg.'y'
    2              0.000043     let &virtualedit = ve
    2              0.000009   elseif a:type =~ '^\d\+$'
                                let type = 'v'
                                silent exe 'norm! ^v'.a:type.'$h"'.reg.'y'
                                if mode() ==# 'v'
                                  norm! v
                                  return s:beep()
                                endif
                              else
                                let &selection = sel_save
                                let &clipboard = cb_save
                                return s:beep()
                              endif
    2              0.000034   let keeper = getreg(reg)
    2              0.000014   if type ==# "v" && a:type !=# "v"
                                let append = matchstr(keeper,'\_s\@<!\s*$')
                                let keeper = substitute(keeper,'\_s\@<!\s*$','','')
                              endif
    2              0.000079   call setreg(reg,keeper,type)
    2   0.003152   0.000071   call s:wrapreg(reg,char,"",a:0 && a:1)
    2              0.000014   if type ==# "v" && a:type !=# "v" && append != ""
                                call setreg(reg,append,"ac")
                              endif
    2   0.001898   0.001319   silent exe 'norm! gv'.(reg == '"' ? '' : '"' . reg).'p`['
    2              0.000032   if type ==# 'V' || (getreg(reg) =~ '\n' && type ==# 'v')
    2   0.019809   0.000056     call s:reindent()
    2              0.000004   endif
    2              0.000081   call setreg(reg,reg_save,reg_type)
    2              0.000032   let &selection = sel_save
    2              0.000024   let &clipboard = cb_save
    2              0.000042   if a:type =~ '^\d\+$'
                                silent! call repeat#set("\<Plug>Y".(a:0 && a:1 ? "S" : "s")."surround".char.s:input,a:type)
                              else
    2   0.000398   0.000074     silent! call repeat#set("\<Plug>SurroundRepeat".char.s:input)
    2              0.000005   endif

FUNCTION  <SNR>52_FindItemAtCursor()
Called 129 times
Total time:   0.016176
 Self time:   0.005771

count  total (s)   self (s)
  129              0.000417     let l:buf = bufnr('')
  129              0.000932     let l:info = get(g:ale_buffer_info, l:buf, {})
  129              0.000669     let l:loclist = get(l:info, 'loclist', [])
  129              0.000559     let l:pos = getcurpos()
  129   0.012183   0.001778     let l:index = ale#util#BinarySearch(l:loclist, l:buf, l:pos[1], l:pos[2])
  129              0.000564     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
  129              0.000386     return [l:info, l:loc]

FUNCTION  <SNR>80_finalize()
Called 23 times
Total time:   0.000676
 Self time:   0.000493

count  total (s)   self (s)
   23              0.000369     autocmd! plugin-clever-f-finalizer
   23   0.000263   0.000080     call s:remove_highlight()
   23              0.000030     let s:moved_forward = 0

FUNCTION  ale#linter#Get()
Called 24 times
Total time:   0.014777
 Self time:   0.007433

count  total (s)   self (s)
   24              0.000122     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
   48              0.000616     for l:original_filetype in split(a:original_filetypes, '\.')
   24   0.003722   0.000353         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
   24   0.002432   0.000341         let l:linter_names = s:GetLinterNames(l:original_filetype)
   24   0.002179   0.000295         let l:all_linters = ale#linter#GetAll(l:filetype)
   24              0.000096         let l:filetype_linters = []
                            
   24              0.000256         if type(l:linter_names) == type('') && l:linter_names is# 'all'
   24              0.000143             let l:filetype_linters = l:all_linters
   24              0.000154         elseif type(l:linter_names) == type([])
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                            
   24              0.000200         call extend(l:possibly_duplicated_linters, l:filetype_linters)
   24              0.000038     endfor
                            
   24              0.000089     let l:name_list = []
   24              0.000094     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   48              0.000254     for l:linter in reverse(l:possibly_duplicated_linters)
   24              0.000196         if index(l:name_list, l:linter.name) < 0
   24              0.000173             call add(l:name_list, l:linter.name)
   24              0.000135             call add(l:combined_linters, l:linter)
   24              0.000040         endif
   24              0.000035     endfor
                            
   24              0.000126     return reverse(l:combined_linters)

FUNCTION  repeat#wrap()
Called 4 times
Total time:   0.000296
 Self time:   0.000296

count  total (s)   self (s)
    4              0.000022     let preserve = (g:repeat_tick == b:changedtick)
    4              0.000031     call feedkeys((a:count ? a:count : '').a:command, 'n')
    4              0.000186     exe (&foldopen =~# 'undo\|all' ? 'norm! zv' : '')
    4              0.000027     if preserve
    2              0.000008         let g:repeat_tick = b:changedtick
    2              0.000003     endif

FUNCTION  <SNR>52_StopCursorTimer()
Called 134 times
Total time:   0.002179
 Self time:   0.002179

count  total (s)   self (s)
  134              0.000485     if s:cursor_timer != -1
  130              0.000654         call timer_stop(s:cursor_timer)
  130              0.000448         let s:cursor_timer = -1
  130              0.000172     endif

FUNCTION  <SNR>14_fixindent()
Called 2 times
Total time:   0.000714
 Self time:   0.000714

count  total (s)   self (s)
    2              0.000069   let str = substitute(a:str,'\t',repeat(' ',&sw),'g')
    2              0.000048   let spc = substitute(a:spc,'\t',repeat(' ',&sw),'g')
    2              0.000540   let str = substitute(str,'\(\n\|\%^\).\@=','\1'.spc,'g')
    2              0.000015   if ! &et
                                let str = substitute(str,'\s\{'.&ts.'\}',"\t",'g')
                              endif
    2              0.000011   return str

FUNCTION  <SNR>67_VimExitCallback()
Called 21 times
Total time:   0.124047
 Self time:   0.002200

count  total (s)   self (s)
   21   0.000906   0.000420     let l:job_id = ale#job#ParseVim8ProcessID(string(a:job))
   21              0.000190     let l:info = get(s:job_map, l:job_id, {})
                            
   21              0.000100     if empty(l:info)
                                    return
                                endif
                            
   21              0.000102     let l:info.exit_code = a:exit_code
                            
                                " The program can exit before the data has finished being read.
   21              0.000185     if ch_status(job_getchannel(a:job)) is# 'closed'
    7              0.000015         try
    7              0.000061             if !empty(l:info) && has_key(l:info, 'exit_cb')
    7   0.121616   0.000255                 call ale#util#GetFunction(l:info.exit_cb)(l:job_id, a:exit_code)
    7              0.000009             endif
    7              0.000015         finally
                                        " Automatically forget about the job after it's done.
    7              0.000082             if has_key(s:job_map, l:job_id)
    7              0.000053                 call remove(s:job_map, l:job_id)
    7              0.000009             endif
    7              0.000012         endtry
    7              0.000006     endif

FUNCTION  ale#highlight#RemoveHighlights()
Called 8 times
Total time:   0.000411
 Self time:   0.000411

count  total (s)   self (s)
   15              0.000106     for l:match in getmatches()
    7              0.000125         if l:match.group =~# '^ALE'
    7              0.000048             call matchdelete(l:match.id)
    7              0.000013         endif
    7              0.000012     endfor

FUNCTION  ale#job#IsRunning()
Called 21 times
Total time:   0.001043
 Self time:   0.001043

count  total (s)   self (s)
   21              0.000335     if has('nvim')
                                    try
                                        " In NeoVim, if the job isn't running, jobpid() will throw.
                                        call jobpid(a:job_id)
                                        return 1
                                    catch
                                    endtry
                                elseif has_key(s:job_map, a:job_id)
                                    let l:job = s:job_map[a:job_id].job
                                    return job_status(l:job) is# 'run'
                                endif
                            
   21              0.000037     return 0

FUNCTION  <SNR>53_GetCounts()
Called 311 times
Total time:   0.012256
 Self time:   0.012256

count  total (s)   self (s)
  311              0.003422     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return s:CreateCountDict()
                                endif
                            
                                " Cache is cold, so manually ask for an update.
  311              0.002111     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                                endif
                            
  311              0.001214     return g:ale_buffer_info[a:buffer].count

FUNCTION  ale#sign#GetSignName()
Called 8 times
Total time:   0.000891
 Self time:   0.000528

count  total (s)   self (s)
    8              0.000045     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
   16              0.000053     for l:item in a:sublist
    8   0.000477   0.000113         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
    8              0.000029         if l:item_priority > l:priority
    8              0.000029             let l:priority = l:item_priority
    8              0.000011         endif
    8              0.000012     endfor
                            
    8              0.000029     if l:priority is# g:ale#util#error_priority
    8              0.000019         return 'ALEErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#warning_priority
                                    return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  <SNR>80_generate_pattern()
Called 69 times
Total time:   0.003478
 Self time:   0.003245

count  total (s)   self (s)
   69              0.000310     let char = type(a:char_num) == type(0) ? nr2char(a:char_num) : a:char_num
   69              0.000076     let regex = char
                            
   69   0.000576   0.000342     let should_use_migemo = s:should_use_migemo(char)
   69              0.000067     if should_use_migemo
                                    if !has_key(s:migemo_dicts, &l:encoding)
                                        let s:migemo_dicts[&l:encoding] = s:load_migemo_dict()
                                    endif
                                    let regex = s:migemo_dicts[&l:encoding][regex] . '\&\%(' . char . '\|\A\)'
                                elseif stridx(g:clever_f_chars_match_any_signs, char) != -1
                                    let regex = '\[!"#$%&''()=~|\-^\\@`[\]{};:+*<>,.?_/]'
                                elseif char ==# '\'
                                    let regex = '\\'
                                endif
                            
   69              0.000244     let is_exclusive_visual = &selection ==# 'exclusive' && mode(1) ==? 'v'
   69              0.000125     if a:map ==# 't' && !is_exclusive_visual
   18              0.000040         let regex = '\_.\ze\%(' . regex . '\)'
   18              0.000020     elseif is_exclusive_visual && a:map ==# 'f'
                                    let regex = '\%(' . regex . '\)\zs\_.'
                                elseif a:map ==# 'T'
                                    let regex = '\%(' . regex . '\)\@<=\_.'
                                endif
                            
   69              0.000080     if !should_use_migemo
   69              0.000110         let regex = '\V'.regex
   69              0.000034     endif
                            
   69              0.000222     return ((g:clever_f_smart_case && char =~# '\l') || g:clever_f_ignore_case ? '\c' : '\C') . regex

FUNCTION  <SNR>54_highlight()
Called 138 times
Total time:   0.008966
 Self time:   0.008946

count  total (s)   self (s)
  138              0.001054   let cur_win = win_getid()
  138              0.002767   if exists('s:win[cur_win].hlight[a:group].pattern') && s:win[cur_win].hlight[a:group].pattern ==# a:pattern
   31              0.000081     return
                              endif
  107              0.001690   if !exists('s:win[cur_win].hlight[a:group].pattern') && empty(a:pattern)
  105              0.000272     return
                              endif
                            
    2              0.000024   if &hlsearch && !empty(a:pattern) && a:group ==# 'TracesSearch'
                                noautocmd let &hlsearch = 0
                              endif
    2              0.000007   if &scrolloff !=# 0
    2              0.000011     let scrolloff = &scrolloff
    2              0.000048     noautocmd let &scrolloff = 0
    2              0.000005   endif
    2              0.000008   if &winwidth isnot 1
    2              0.000042     noautocmd set winwidth=1
    2              0.000005   endif
    2              0.000007   if &winheight isnot 1
                                noautocmd set winheight=1
                              endif
                            
    2   0.000330   0.000310   let windows = filter(win_findbuf(s:nr), {_, val -> win_id2win(val)})
    4              0.000022   for id in windows
    2              0.000042     let wininfo = getwininfo(id)[0]
    2              0.000015     if wininfo.height is 0 || wininfo.width is 0
                                  " skip minimized windows
                                  continue
                                endif
    2              0.000035     noautocmd call win_gotoid(id)
    2              0.000035     let s:win[id] = get(s:win, id, {})
    2              0.000035     let s:win[id].hlight = get(s:win[id], 'hlight', {})
                            
    2              0.000033     if !exists('s:win[id].hlight[a:group]')
    2              0.000009       let x = {}
    2              0.000014       let x.pattern = a:pattern
    2              0.000093       silent! let x.index = matchadd(a:group, a:pattern, a:priority)
    2              0.000026       let s:win[id].hlight[a:group] = x
    2              0.000011       let s:highlighted = 1
    2              0.000015     elseif s:win[id].hlight[a:group].pattern !=# a:pattern
                                  if s:win[id].hlight[a:group].index !=# -1
                                    silent! call matchdelete(s:win[id].hlight[a:group].index)
                                  endif
                                  let s:win[id].hlight[a:group].pattern = a:pattern
                                  silent! let s:win[id].hlight[a:group].index = matchadd(a:group, a:pattern, a:priority)
                                  let s:highlighted = 1
                                endif
    2              0.000020     if (&conceallevel !=# 2 || &concealcursor !=# 'c') && a:group ==# 'Conceal'
                                  let s:win[id].options = get(s:win[id], 'options', {})
                                  let s:win[id].options.conceallevel = &conceallevel
                                  let s:win[id].options.concealcursor = &concealcursor
                                  noautocmd set conceallevel=2
                                  noautocmd set concealcursor=c
                                endif
                                " highlighting doesn't work properly when cursorline or cursorcolumn is
                                " enabled
    2              0.000010     if &cursorcolumn || &cursorline
    2              0.000035       let s:win[id].options = get(s:win[id], 'options', {})
    2              0.000020       let s:win[id].options.cursorcolumn = &cursorcolumn
    2              0.000018       let s:win[id].options.cursorline = &cursorline
    2              0.000041       noautocmd set nocursorcolumn
    2              0.000033       noautocmd set nocursorline
    2              0.000005     endif
    2              0.000008   endfor
    2              0.000023   if bufname('%') !=# '[Command Line]'
    2              0.000032     noautocmd call win_gotoid(cur_win)
    2              0.000005   endif
    2              0.000014   if exists('scrolloff')
    2              0.000041     noautocmd let &scrolloff = scrolloff
    2              0.000004   endif

FUNCTION  ale#highlight#UpdateHighlights()
Called 8 times
Total time:   0.002551
 Self time:   0.002011

count  total (s)   self (s)
    8              0.000100     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    8   0.000524   0.000113     call ale#highlight#RemoveHighlights()
                            
   16              0.000052     for l:item in l:item_list
    8              0.000032         if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
    8              0.000027             let l:group = 'ALEError'
    8              0.000012         endif
                            
    8              0.000029         let l:line = l:item.lnum
    8              0.000028         let l:col = l:item.col
    8              0.000052         let l:end_line = get(l:item, 'end_lnum', l:line)
    8              0.000049         let l:end_col = get(l:item, 'end_col', l:col)
                            
                                    " Set all of the positions, which are chunked into Lists which
                                    " are as large as will be accepted by matchaddpos.
    8   0.000358   0.000229         call map(   ale#highlight#CreatePositions(l:line, l:col, l:end_line, l:end_col),   'matchaddpos(l:group, v:val)')
    8              0.000014     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    8              0.000023     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call matchaddpos(l:group, [l:item.lnum])
                                        endif
                                    endfor
                                endif

FUNCTION  <SNR>67_VimOutputCallback()
Called 8 times
Total time:   0.000905
 Self time:   0.000524

count  total (s)   self (s)
    8              0.000134     let l:job = ch_getjob(a:channel)
    8   0.000319   0.000140     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                            
                                " Only call the callbacks for jobs which are valid.
    8              0.000061     if l:job_id > 0 && has_key(s:job_map, l:job_id)
    8   0.000343   0.000140         call ale#util#GetFunction(s:job_map[l:job_id].out_cb)(l:job_id, a:data)
    8              0.000005     endif

FUNCTION  ale#semver#HasVersion()
Called 11 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
   11              0.000099     return has_key(s:version_cache, a:executable)

FUNCTION  ale#job#Start()
Called 21 times
Total time:   2.760919
 Self time:   2.759911

count  total (s)   self (s)
   21   0.000576   0.000302     call ale#job#ValidateArguments(a:command, a:options)
                            
   21              0.000217     let l:job_info = copy(a:options)
   21              0.000080     let l:job_options = {}
                            
   21              0.000350     if has('nvim')
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.on_stdout = function('s:NeoVimCallback')
                                        let l:job_info.out_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        let l:job_options.on_exit = function('s:NeoVimCallback')
                                    endif
                            
                                    let l:job_info.job = jobstart(a:command, l:job_options)
                                    let l:job_id = l:job_info.job
                                else
   21              0.000256         let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
   21              0.000109         if has_key(a:options, 'out_cb')
   10              0.000099             let l:job_options.out_cb = function('s:VimOutputCallback')
   10              0.000012         endif
                            
   21              0.000095         if has_key(a:options, 'err_cb')
   11              0.000151             let l:job_options.err_cb = function('s:VimErrorCallback')
   11              0.000018         endif
                            
   21              0.000099         if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
   21              0.000231             let l:job_options.close_cb = function('s:VimCloseCallback')
   21              0.000223             let l:job_options.exit_cb = function('s:VimExitCallback')
   21              0.000029         endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
   21              2.754779         let l:job_info.job = job_start(a:command, l:job_options)
   21   0.001530   0.000795         let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
   21              0.000066     endif
                            
   21              0.000064     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
   21              0.000184         let s:job_map[l:job_id] = l:job_info
   21              0.000023     endif
                            
   21              0.000056     return l:job_id

FUNCTION  <SNR>54_skip_modifiers()
Called 62 times
Total time:   0.023045
 Self time:   0.023045

count  total (s)   self (s)
   62              0.000345   let cmdl = a:cmdl
                            
                              " skip leading colon
   62              0.001879   let cmdl = substitute(cmdl, '\v^:+', '', '')
                            
                              " skip modifiers
   62              0.001846   let pattern = '\v^\s*%(' . 'sil%[ent]\!=|' . 'verb%[ose]|' . 'noa%[utocmd]|' . 'loc%[kmarks]' . 'keepp%[atterns]|' . 'keepa%[lt]|' . 'keepj%[umps]|' . 'kee%[pmarks]|' . ')\s+'
   62              0.000294   while 1
   62              0.004371     let offset = matchstrpos(cmdl, pattern)
   62              0.000546     if offset[2] isnot -1
                                  let cmdl = strcharpart(cmdl, offset[2])
                                else
   62              0.000215       break
                                endif
                              endwhile
                            
   62              0.000324   if g:traces_skip_modifiers
                                " skip *do modifiers
   62              0.004665     let cmdl = substitute(cmdl, '\v^\s*%(%(%(\d+|\.|\$|\%)\s*[,;]=\s*)+)=\s*%(cdo|cfdo|ld%[o]|lfdo' . '|bufd%[o]|tabd%[o]|argdo|wind%[o])\!=\s+', '', '')
                            
                                " skip modifiers
   62              0.000229     while 1
   62              0.003143       let offset = matchstrpos(cmdl, pattern)
   62              0.000440       if offset[2] isnot -1
                                    let cmdl = strcharpart(cmdl, offset[2])
                                  else
   62              0.000177         break
                                  endif
                                endwhile
   62              0.000137   endif
                            
   62              0.000276   return cmdl

FUNCTION  <SNR>54_get_selection_regexp()
Called 62 times
Total time:   0.002653
 Self time:   0.002653

count  total (s)   self (s)
   62              0.000379   if empty(a:range)
   29              0.000100     return ''
                              endif
   33              0.000688   let pattern = '\%>' . (a:range[-2] - 1) . 'l\%<' . (a:range[-1]  + 1) . 'l'
   33              0.000489   if &listchars =~# 'eol:.'
                                let pattern .= '\_.'
                              else
   33              0.000228     let pattern .= '\(.\|^\)'
   33              0.000060   endif
   33              0.000131   return pattern

FUNCTION  <SNR>80_mark_char_in_current_line()
Called 23 times
Total time:   0.001648
 Self time:   0.000424

count  total (s)   self (s)
   23   0.001457   0.000233     let regex = '\%' . line('.') . 'l' . s:generate_pattern(a:map, a:char)
   23              0.000178     call matchadd('CleverFChar', regex , 999)

FUNCTION  <SNR>22_MatchesAbove()
Called 7 times
Total time:   0.002739
 Self time:   0.000652

count  total (s)   self (s)
                              " avoid wrapping range at the beginning of file
    7              0.000059   if line('.') == 1 | return 0 | endif
                            
    7              0.000050   let [old_line, old_result, total] = a:cached_values
                              " Find the nearest point from which we can restart match counting (top,
                              " bottom, or previously cached line).
    7              0.000030   let line = line('.')
    7              0.000019   let to_top = line
    7              0.000055   let to_old = abs(line - old_line)
    7              0.000042   let to_bottom = line('$') - line
    7              0.000060   let min_dist = min([to_top, to_old, to_bottom])
                            
    7              0.000019   if min_dist == to_top
                                return s:MatchesInRange('1,.-1')
                              elseif min_dist == to_bottom
    1   0.000291   0.000012     return total - s:MatchesInRange(',$')
                              " otherwise, min_dist == to_old, we just need to check relative line order
                              elseif old_line < line
    6   0.001923   0.000116     return old_result + s:MatchesInRange(old_line . ',-1')
                              elseif old_line > line
                                return old_result - s:MatchesInRange(',' . (old_line - 1))
                              else " old_line == line
                                return old_result
                              endif

FUNCTION  ale#history#RememberOutput()
Called 8 times
Total time:   0.000504
 Self time:   0.000151

count  total (s)   self (s)
    8   0.000447   0.000095     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    8              0.000039     let l:obj.output = a:output

FUNCTION  ale#engine#ManageDirectory()
Called 10 times
Total time:   0.000680
 Self time:   0.000292

count  total (s)   self (s)
   10   0.000520   0.000132     call ale#engine#InitBufferInfo(a:buffer)
   10              0.000141     call add(g:ale_buffer_info[a:buffer].temporary_directory_list, a:directory)

FUNCTION  ale#Var()
Called 260 times
Total time:   0.014599
 Self time:   0.014599

count  total (s)   self (s)
  260              0.001893     let l:nr = str2nr(a:buffer)
  260              0.001595     let l:full_name = 'ale_' . a:variable_name
                            
  260              0.001360     if bufexists(l:nr)
  260              0.001693         let l:vars = getbufvar(l:nr, '')
  260              0.001148     elseif has_key(g:, 'ale_fix_buffer_data')
                                    let l:vars = get(g:ale_fix_buffer_data, l:nr, {'vars': {}}).vars
                                else
                                    let l:vars = {}
                                endif
                            
  260              0.002378     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>11_default_register()
Called 49 times
Total time:   0.000885
 Self time:   0.000885

count  total (s)   self (s)
   49              0.000438   let clipboard_flags = split(&clipboard, ',')
   49              0.000170   if index(clipboard_flags, 'unnamedplus') >= 0
                                return "+"
                              elseif index(clipboard_flags, 'unnamed') >= 0
   49              0.000059     return "*"
                              else
                                return "\""
                              endif

FUNCTION  ale#ShouldDoNothing()
Called 161 times
Total time:   0.027706
 Self time:   0.021409

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                            
                                " Do nothing if ALE is disabled.
  161              0.001662     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
  161              0.001130     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
  161              0.001306     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
  161              0.000476     if l:filetype is# ''
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
  161              0.001485     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
  161              0.001123     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
  161              0.001413     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
  161              0.000427     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
  161   0.004716   0.001270     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
  161   0.004126   0.001275     if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
  161              0.001735     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
  161              0.000243     return 0

FUNCTION  <SNR>76_BufWinId()
Called 8 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
    8              0.000168     return exists('*bufwinid') ? bufwinid(str2nr(a:buffer)) : 0

FUNCTION  <SNR>24_create_cmdl_changed_au()
Called 4 times
Total time:   0.001338
 Self time:   0.000771

count  total (s)   self (s)
    4              0.000067   augroup traces_augroup_cmdline_changed
    4              0.000387     autocmd!
    4              0.000127     autocmd CmdlineChanged : call s:cmdline_changed()
    4              0.000014   augroup END
                              " necessary when entering command line that has already been populated with
                              " text from mappings
    4   0.000691   0.000124   call s:cmdline_changed()

FUNCTION  <SNR>54_save_marks()
Called 4 times
Total time:   0.000497
 Self time:   0.000497

count  total (s)   self (s)
    4              0.000049   if !exists('s:buf[s:nr].marks')
    4              0.000031     let types = ['[', ']']
    4              0.000033     let s:buf[s:nr].marks  = {}
   12              0.000076     for mark in types
    8              0.000200       let s:buf[s:nr].marks[mark] = getpos("'" . mark)
    8              0.000025     endfor
    4              0.000010   endif

FUNCTION  ale#sign#ParseSigns()
Called 8 times
Total time:   0.003074
 Self time:   0.003074

count  total (s)   self (s)
                                " Matches output like :
                                " line=4  id=1  name=ALEErrorSign
                                " =1  id=1000001  =ALEErrorSign
                                " =1  =1000001  =ALEWarningSign
                                " lnea=12 id=1000001 nombre=ALEWarningSign
                                " riga=1 id=1000001, nome=ALEWarningSign
    8              0.000035     let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
    8              0.000023     let l:result = []
    8              0.000031     let l:is_dummy_sign_set = 0
                            
   39              0.000122     for l:line in a:line_list
   31              0.001381         let l:match = matchlist(l:line, l:pattern)
                            
   31              0.000143         if len(l:match) > 0
   15              0.000096             if l:match[3] is# 'ALEDummySign'
    8              0.000092                 let l:is_dummy_sign_set = 1
    8              0.000018             else
    7              0.000125                 call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
    7              0.000012             endif
   15              0.000021         endif
   31              0.000058     endfor
                            
    8              0.000041     return [l:is_dummy_sign_set, l:result]

FUNCTION  searchindex#MatchCounts()
Called 8 times
Total time:   0.007711
 Self time:   0.001638

count  total (s)   self (s)
                              " both :s and search() modify cursor position
    8              0.000070   let win_view = winsaveview()
                              " folds affect range of ex commands (issue #4)
    8              0.000036   let save_foldenable = &foldenable
    8              0.000086   set nofoldenable
                            
    8   0.002913   0.000097   let in_line = s:MatchInLine()
                            
    8              0.000046   let cache_key = [b:changedtick, @/]
    8              0.000073   if exists('b:searchindex_cache_key') && b:searchindex_cache_key ==# cache_key
    7   0.002869   0.000130     let before = s:MatchesAbove(b:searchindex_cache_val)
    7              0.000052     let total = b:searchindex_cache_val[-1]
    7              0.000013   else
    1   0.000125   0.000011     let before = (line('.') == 1 ? 0 : s:MatchesInRange('1,-1'))
    1   0.000411   0.000006     let total = before + s:MatchesInRange(',$')
    1              0.000001   endif
                            
    8              0.000065   let b:searchindex_cache_val = [line('.'), before, total]
    8              0.000033   let b:searchindex_cache_key = cache_key
                            
    8              0.000067   let &foldenable = save_foldenable
    8              0.000560   call winrestview(win_view)
                            
    8              0.000049   return [before + in_line, total]

FUNCTION  ale#history#SetExitCode()
Called 18 times
Total time:   0.001479
 Self time:   0.000460

count  total (s)   self (s)
   18   0.001251   0.000232     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
   18              0.000093     let l:obj.exit_code = a:exit_code
   18              0.000064     let l:obj.status = 'finished'

FUNCTION  ale#util#Writefile()
Called 10 times
Total time:   0.171361
 Self time:   0.171361

count  total (s)   self (s)
   10              0.000188     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'v:val . "\r"')   : a:lines
                            
   10              0.171134     call writefile(l:corrected_lines, a:filename) " no-custom-checks

FUNCTION  ale_linters#vim#vint#VersionCommand()
Called 11 times
Total time:   0.002062
 Self time:   0.000568

count  total (s)   self (s)
   11   0.001028   0.000164     let l:executable = ale_linters#vim#vint#GetExecutable(a:buffer)
                            
                                " Check the Vint version if we haven't checked it already.
   11   0.000985   0.000355     return !ale#semver#HasVersion(l:executable)   ? ale#Escape(l:executable) . ' --version'   : ''

FUNCTION  clever_f#repeat()
Called 46 times
Total time:   0.001921
 Self time:   0.001921

count  total (s)   self (s)
   46              0.000115     let mode = mode(1)
   46              0.000131     let pmap = get(s:previous_map, mode, '')
   46              0.000122     let prev_char_num = get(s:previous_char_num, mode, 0)
                            
   46              0.000053     if pmap ==# ''
                                    return ''
                                endif
                            
                                " ignore special characters like \<Left>
   46              0.000164     if type(prev_char_num) == type('') && char2nr(prev_char_num) == 128
                                    return ''
                                endif
                            
   46              0.000035     if a:back
                                    let pmap = s:swapcase(pmap)
                                endif
                            
   46              0.000111     if mode ==? 'v' || mode ==# "\<C-v>"
                                    let cmd = s:move_cmd_for_visualmode(pmap, prev_char_num)
                                else
   46              0.000204         let inclusive = mode ==# 'no' && pmap =~# '\l'
   46              0.000352         let cmd = printf("%s:\<C-u>call clever_f#find(%s, %s)\<CR>",    inclusive ? 'v' : '',    string(pmap), prev_char_num)
   46              0.000022     endif
                            
   46              0.000049     return cmd

FUNCTION  <SNR>54_pos_range()
Called 37 times
Total time:   0.002794
 Self time:   0.002794

count  total (s)   self (s)
   37              0.000332   if g:traces_preserve_view_state || empty(a:end)
    4              0.000009     return
                              endif
   33              0.000375   call cursor([a:end, 1])
   33              0.000385   if exists('s:buf[s:nr].pre_cmdl_view')
    2              0.000284     call winrestview(s:buf[s:nr].pre_cmdl_view)
    2              0.000018     unlet s:buf[s:nr].pre_cmdl_view
    2              0.000004   endif
   33              0.000190   if !empty(a:pattern)
                                call search(a:pattern, 'c', a:end, s:s_timeout)
                              endif
   33              0.000145   let s:moved = 1

FUNCTION  ale#cursor#EchoCursorWarning()
Called 133 times
Total time:   0.059511
 Self time:   0.010831

count  total (s)   self (s)
  133              0.000807     if !g:ale_echo_cursor
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  133              0.000816     if mode() isnot# 'n'
    4              0.000008         return
                                endif
                            
  129   0.021971   0.001420     if ale#ShouldDoNothing(bufnr(''))
                                    return
                                endif
                            
  129              0.000508     let l:buffer = bufnr('')
  129   0.017633   0.001457     let [l:info, l:loc] = s:FindItemAtCursor()
                            
  129              0.000412     if !empty(l:loc)
    8   0.000421   0.000079         let l:format = ale#Var(l:buffer, 'echo_msg_format')
    8   0.001218   0.000087         let l:msg = ale#GetLocItemMessage(l:loc, l:format)
    8   0.010579   0.000100         call ale#cursor#TruncatedEcho(l:msg)
    8              0.000027         let l:info.echoed = 1
    8              0.000031     elseif get(l:info, 'echoed')
                                    " We'll only clear the echoed message when moving off errors once,
                                    " so we don't continually clear the echo line.
    4              0.000097         execute 'echo'
    4              0.000012         let l:info.echoed = 0
    4              0.000005     endif

FUNCTION  ale#GetLocItemMessage()
Called 16 times
Total time:   0.002825
 Self time:   0.002825

count  total (s)   self (s)
   16              0.000063     let l:msg = a:format_string
   16              0.000077     let l:severity = g:ale_echo_msg_warning_str
   16              0.000162     let l:code = get(a:item, 'code', '')
   16              0.000097     let l:type = get(a:item, 'type', 'E')
   16              0.000113     let l:linter_name = get(a:item, 'linter_name', '')
   16              0.000118     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
   16              0.000060     if l:type is# 'E'
   16              0.000077         let l:severity = g:ale_echo_msg_error_str
   16              0.000036     elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
                                endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
   16              0.000390     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
   16              0.000246     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
   16              0.000737     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
                                " Replace %s with the text.
   16              0.000298     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                            
   16              0.000048     return l:msg

FUNCTION  <SNR>76_SetListsImpl()
Called 8 times
Total time:   0.021961
 Self time:   0.015932

count  total (s)   self (s)
    8              0.013139     let l:title = expand('#' . a:buffer . ':p')
                            
    8              0.000052     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, bufwinid() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    8   0.000333   0.000150         let l:id = s:BufWinId(a:buffer)
                            
    8              0.000173         if has('nvim')
                                        call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                    else
    8   0.003753   0.000273             call setloclist(l:id, s:FixList(a:buffer, a:loclist))
    8              0.000117             call setloclist(l:id, [], 'r', {'title': l:title})
    8              0.000015         endif
    8              0.000014     endif
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    8   0.000939   0.000148     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                                    let l:reset_visual_selection = l:mode is? 'v' || l:mode is# "\<c-v>"
                                    let l:reset_character_selection = l:mode is? 's' || l:mode is# "\<c-s>"
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert '
                                    endif
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    if l:reset_visual_selection || l:reset_character_selection
                                        " If we were in a selection mode before, select the last selection.
                                        normal! gv
                            
                                        if l:reset_character_selection
                                            " Switch back to Select mode, if we were in that.
                                            normal! "\<c-g>"
                                        endif
                                    endif
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    8   0.000299   0.000104     if !ale#engine#IsCheckingBuffer(a:buffer)
    8   0.001496   0.000116         call s:CloseWindowIfNeeded(a:buffer)
    8              0.000012     endif

FUNCTION  ale#sign#SetSigns()
Called 8 times
Total time:   0.085513
 Self time:   0.074509

count  total (s)   self (s)
    8              0.000062     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
    8   0.003933   0.000166     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    8   0.001058   0.000154     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    8   0.000815   0.000130     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    8   0.003888   0.000138     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    8   0.002039   0.000141     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    8              0.000051     if g:ale_change_sign_column_color && !empty(a:loclist)
    8              0.000128         highlight clear SignColumn
    8              0.000123         highlight link SignColumn ALESignColumnWithErrors
    8              0.000016     endif
                            
   17              0.000089     for l:command in l:command_list
    9              0.072830         silent! execute l:command
    9              0.000051     endfor
                            
                                " Reset the sign column color when there are no more errors.
    8              0.000069     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif

FUNCTION  <SNR>54_add_flags()
Called 62 times
Total time:   0.000781
 Self time:   0.000781

count  total (s)   self (s)
   62              0.000450   if !len(a:pattern)
   62              0.000200     return ''
                              endif
                              if !s:range_valid
                                return ''
                              endif
                              if !len(substitute(a:pattern, '\\[cCvVmM]', '', 'g'))
                                return ''
                              endif
                            
                              let option = ''
                            
                              " magic
                              if has_key(a:cmdl, 'cmd') && a:cmdl.cmd.name =~# '\v^sm%[agic]$'
                                let option = '\m'
                              elseif  has_key(a:cmdl, 'cmd') && a:cmdl.cmd.name =~# '\v^sno%[magic]$'
                                let option = '\M'
                              elseif &magic
                                let option = '\m'
                              else
                                let option = '\M'
                              endif
                            
                              " case
                              if &ignorecase
                                if &smartcase
                                  if match(a:pattern, '\u') ==# -1
                                    let option .= '\c'
                                  else
                                    let option .= '\C'
                                  endif
                                else
                                  let option .= '\c'
                                endif
                              endif
                            
                              if !empty(a:cmdl.range.abs)
                                let start = a:cmdl.range.abs[-2] - 1
                                let end   = a:cmdl.range.abs[-1] + 1
                              elseif a:type ==# 1
                                return option . a:pattern
                              elseif a:type ==# 2
                                let start = s:buf[s:nr].cur_init_pos[0] - 1
                                let end   = s:buf[s:nr].cur_init_pos[0] + 1
                              endif
                            
                              " range pattern specifer
                              if a:type == 3
                                let start = a:cmdl.range.end - 1
                                let end   = a:cmdl.range.end + 1
                              endif
                            
                              let range = '\m\%>'. start .'l' . '\%<' . end . 'l'
                            
                              " group is necessary to contain pattern inside range when using branches (\|)
                              let group_start = '\%('
                              let group_end   = '\m\)'
                              " add backslash to the end of pattern if it ends with odd number of
                              " backslashes, this is required to properly close group
                              if len(matchstr(a:pattern, '\\\+$')) % 2
                                let group_end = '\' . group_end
                              endif
                            
                              return range . group_start . option . a:pattern . group_end

FUNCTION  ale#job#Stop()
Called 21 times
Total time:   0.003226
 Self time:   0.002183

count  total (s)   self (s)
   21              0.000130     if !has_key(s:job_map, a:job_id)
                                    return
                                endif
                            
   21              0.000317     if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
                                    silent! call jobstop(a:job_id)
                                else
   21              0.000117         let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
   21              0.000174         if ch_status(job_getchannel(l:job)) is# 'open'
    3              0.000023             call ch_close_in(job_getchannel(l:job))
    3              0.000002         endif
                            
                                    " Ask nicely for the job to stop.
   21              0.000381         call job_stop(l:job)
                            
   21   0.001238   0.000195         if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
   21              0.000026     endif

FUNCTION  ale#engine#InitBufferInfo()
Called 21 times
Total time:   0.000792
 Self time:   0.000792

count  total (s)   self (s)
   21              0.000228     if !has_key(g:ale_buffer_info, a:buffer)
                                    " job_list will hold the list of job IDs
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    " temporary_file_list holds temporary files to be cleaned up
                                    " temporary_directory_list holds temporary directories to be cleaned up
                                    let g:ale_buffer_info[a:buffer] = {   'job_list': [],   'active_linter_list': [],   'loclist': [],   'temporary_file_list': [],   'temporary_directory_list': [],}
                            
                                    return 1
                                endif
                            
   21              0.000047     return 0

FUNCTION  <SNR>53_CreateCountDict()
Called 8 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
    8              0.000113     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  <SNR>66_TemporaryFilename()
Called 10 times
Total time:   0.088667
 Self time:   0.088218

count  total (s)   self (s)
   10              0.000099     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
   10              0.000044     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
   10              0.000100         let l:ft = getbufvar(a:buffer, '&filetype')
   10   0.000587   0.000137         let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
   10              0.000013     endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
   10              0.087731     return tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  <SNR>58_ApplyPartialTimer()
Called 8 times
Total time:   0.022676
 Self time:   0.000715

count  total (s)   self (s)
    8              0.000235     if has_key(s:partial_timers, a:timer_id)
    8              0.000197         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    8   0.022192   0.000231         call call(l:Callback, [a:timer_id] + l:args)
    8              0.000012     endif

FUNCTION  ale#statusline#Count()
Called 311 times
Total time:   0.017777
 Self time:   0.005521

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
  311   0.016997   0.004741     return copy(s:GetCounts(a:buffer))

FUNCTION  ale#FileTooLarge()
Called 161 times
Total time:   0.002850
 Self time:   0.002850

count  total (s)   self (s)
  161              0.001494     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
  161              0.001046     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  GetVimIndentIntern()
Called 42 times
Total time:   0.016996
 Self time:   0.016996

count  total (s)   self (s)
                              " Find a non-blank line above the current line.
   42              0.000438   let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' and below a line that starts
                              " with '\', use the indent of the line above it.
   42              0.000345   let cur_text = getline(v:lnum)
   42              0.000729   if cur_text !~ '^\s*\\'
   42              0.000768     while lnum > 0 && getline(lnum) =~ '^\s*\\'
                                  let lnum = lnum - 1
                                endwhile
   42              0.000080   endif
                            
                              " At the start of the file use zero indent.
   42              0.000133   if lnum == 0
                                return 0
                              endif
   42              0.000314   let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' after
                              " a line that doesn't (or g:vim_indent_cont if it exists).
   42              0.000281   let ind = indent(lnum)
   42              0.000617   if cur_text =~ '^\s*\\' && v:lnum > 1 && prev_text !~ '^\s*\\'
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
   42              0.000660     if prev_text !~ '^\s*au\%[tocmd]'
   42              0.002209       let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
   42              0.000147       if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items') && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
   42              0.000080     endif
   42              0.000079   endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
   42              0.001083   let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
   42              0.000192   if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
   42              0.001432   if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
   42              0.000143   return ind

FUNCTION  ale_linters#vim#vint#GetExecutable()
Called 32 times
Total time:   0.002435
 Self time:   0.000434

count  total (s)   self (s)
   32   0.002407   0.000406     return ale#Var(a:buffer, 'vim_vint_executable')

FUNCTION  <SNR>63_RemoveProblemsForDisabledLinters()
Called 11 times
Total time:   0.000730
 Self time:   0.000730

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
   11              0.000047     let l:name_map = {}
                            
   22              0.000086     for l:linter in a:linters
   11              0.000100         let l:name_map[l:linter.name] = 1
   11              0.000023     endfor
                            
   11              0.000301     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  ale#engine#IsCheckingBuffer()
Called 27 times
Total time:   0.000603
 Self time:   0.000603

count  total (s)   self (s)
   27              0.000270     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   27              0.000257     return !empty(get(l:info, 'active_linter_list', []))

FUNCTION  ale#job#ValidateArguments()
Called 21 times
Total time:   0.000273
 Self time:   0.000273

count  total (s)   self (s)
   21              0.000138     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
                                endif

FUNCTION  ale#command#FormatCommand()
Called 21 times
Total time:   0.092797
 Self time:   0.003670

count  total (s)   self (s)
   21              0.000088     let l:temporary_file = ''
   21              0.000082     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
   21              0.000424     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
   21              0.000191     if l:command =~# '%s'
                                    let l:filename = fnamemodify(bufname(a:buffer), ':p')
                                    let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
                                endif
                            
   21              0.000159     if l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
   10   0.088856   0.000188         let l:temporary_file = s:TemporaryFilename(a:buffer)
   10   0.000936   0.000477         let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
   10              0.000014     endif
                            
                                " Finish formatting so %% becomes %.
   21              0.000429     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
   21              0.000154     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
                                endif
                            
   21              0.000124     return [l:temporary_file, l:command]

FUNCTION  ale#job#ParseVim8ProcessID()
Called 71 times
Total time:   0.002292
 Self time:   0.002292

count  total (s)   self (s)
   71              0.002174     return matchstr(a:job_string, '\d\+') + 0

FUNCTION  <SNR>80_should_use_migemo()
Called 69 times
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
   69              0.000119     if !g:clever_f_use_migemo || a:char !~# '^\a$'
   69              0.000052         return 0
                                endif
                            
                                if !g:clever_f_across_no_line
                                    return 1
                                endif
                            
                                return s:include_multibyte_char(getline('.'))

FUNCTION  ale#engine#ProcessChain()
Called 21 times
Total time:   0.009831
 Self time:   0.004590

count  total (s)   self (s)
   21              0.000182     let l:output_stream = get(a:linter, 'output_stream', 'stdout')
   21              0.000094     let l:read_buffer = a:linter.read_buffer
   21              0.000086     let l:chain_index = a:chain_index
   21              0.000070     let l:input = a:input
                            
   21              0.000112     if has_key(a:linter, 'command_chain')
   21              0.000151         while l:chain_index < len(a:linter.command_chain)
                                        " Run a chain of commands, one asynchronous command after the other,
                                        " so that many programs can be run in a sequence.
   21              0.000153             let l:chain_item = a:linter.command_chain[l:chain_index]
                            
   21              0.000080             if l:chain_index == 0
                                            " The first callback in the chain takes only a buffer number.
   11   0.002562   0.000301                 let l:command = ale#util#GetFunction(l:chain_item.callback)(   a:buffer)
   11              0.000025             else
                                            " The second callback in the chain takes some input too.
   10   0.003208   0.000227                 let l:command = ale#util#GetFunction(l:chain_item.callback)(   a:buffer,   l:input)
   10              0.000016             endif
                            
   21              0.000123             if !empty(l:command)
                                            " We hit a command to run, so we'll execute that
                            
                                            " The chain item can override the output_stream option.
   21              0.000134                 if has_key(l:chain_item, 'output_stream')
   21              0.000133                     let l:output_stream = l:chain_item.output_stream
   21              0.000037                 endif
                            
                                            " The chain item can override the read_buffer option.
   21              0.000120                 if has_key(l:chain_item, 'read_buffer')
                                                let l:read_buffer = l:chain_item.read_buffer
                                            elseif l:chain_index != len(a:linter.command_chain) - 1
                                                " Don't read the buffer for commands besides the last one
                                                " in the chain by default.
   11              0.000046                     let l:read_buffer = 0
   11              0.000020                 endif
                            
   21              0.000079                 break
                                        endif
                            
                                        " Command chain items can return an empty string to indicate that
                                        " a command should be skipped, so we should try the next item
                                        " with no input.
                                        let l:input = []
                                        let l:chain_index += 1
                                    endwhile
   21              0.000033     else
                                    let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                                endif
                            
   21              0.000415     return {   'command': l:command,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': l:output_stream,   'next_chain_index': l:chain_index + 1,   'read_buffer': l:read_buffer,}

FUNCTION  <SNR>24_t_stop()
Called 71 times
Total time:   0.005014
 Self time:   0.005014

count  total (s)   self (s)
   71              0.000262   if exists('s:previous_cmdl')
                                unlet s:previous_cmdl
                              endif
   71              0.000233   if exists('s:track_cmdl_timer')
   71              0.000295     call timer_stop(s:track_cmdl_timer)
   71              0.000140     unlet s:track_cmdl_timer
   71              0.000052   endif
   71              0.000190   if exists('s:start_init_timer')
    4              0.000008     call timer_stop(s:start_init_timer)
    4              0.000005     unlet s:start_init_timer
    4              0.000002   endif
   71              0.000180   augroup traces_augroup_cmdline_changed
   71              0.002801     autocmd!
   71              0.000074   augroup END

FUNCTION  highlightedyank#debounce()
Called 52 times
Total time:   0.004198
 Self time:   0.004198

count  total (s)   self (s)
   52              0.000125   if s:state is s:OFF
                                return
                              endif
                            
   52              0.000151   let operator = v:event.operator
   52              0.000106   let regtype = v:event.regtype
   52              0.000156   let regcontents = v:event.regcontents
   52              0.000406   let marks = [line("'["), line("']"), col("'["), col("']")]
   52              0.000076   if s:timer isnot -1
   46              0.000967     call timer_stop(s:timer)
   46              0.000035   endif
                            
                              " NOTE: The timer callback would not be called while vim is busy, thus the
                              "       highlight procedure starts after the control has been returned to
                              "       user.
                              "       This makes complex-repeat faster because the highlight doesn't
                              "       performed in a macro execution.
   52              0.001613   let s:timer = timer_start(1, {-> s:highlight(operator, regtype, regcontents, marks)})

FUNCTION  <SNR>74_RemoveUnicodeQuotes()
Called 8 times
Total time:   0.000924
 Self time:   0.000924

count  total (s)   self (s)
    8              0.000033     let l:text = a:text
    8              0.000360     let l:text = substitute(l:text, '[`]', '''', 'g')
    8              0.000242     let l:text = substitute(l:text, '\v\\u2018([^\\]+)\\u2019', '''\1''', 'g')
    8              0.000234     let l:text = substitute(l:text, '[]', '"', 'g')
                            
    8              0.000022     return l:text

FUNCTION  <SNR>14_wrapreg()
Called 2 times
Total time:   0.003081
 Self time:   0.000250

count  total (s)   self (s)
    2              0.000029   let orig = getreg(a:reg)
    2              0.000068   let type = substitute(getregtype(a:reg),'\d\+$','','')
    2   0.002905   0.000074   let new = s:wrap(orig,a:char,type,a:removed,a:special)
    2              0.000071   call setreg(a:reg,new,type)

FUNCTION  ale#Queue()
Called 13 times
Total time:   0.011361
 Self time:   0.002085

count  total (s)   self (s)
   13              0.000034     if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
                                " Default linting_flag to ''
   13              0.000099     let l:linting_flag = get(a:000, 0, '')
   13              0.000130     let l:buffer = get(a:000, 1, bufnr(''))
                            
   13              0.000073     if l:linting_flag isnot# '' && l:linting_flag isnot# 'lint_file'
                                    throw "linting_flag must be either '' or 'lint_file'"
                                endif
                            
   13              0.000082     if type(l:buffer) != type(0)
                                    throw 'buffer_number must be a Number'
                                endif
                            
   13   0.002657   0.000129     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                " Remember that we want to check files for this buffer.
                                " We will remember this until we finally run the linters, via any event.
   13              0.000051     if l:linting_flag is# 'lint_file'
                                    let s:should_lint_file_for_buffer[l:buffer] = 1
                                endif
                            
   13              0.000035     if s:lint_timer != -1
   13              0.000068         call timer_stop(s:lint_timer)
   13              0.000041         let s:lint_timer = -1
   13              0.000015     endif
                            
   13   0.006997   0.000250     let l:linters = ale#linter#Get(getbufvar(l:buffer, '&filetype'))
                            
                                " Don't set up buffer data and so on if there are no linters to run.
   13              0.000049     if empty(l:linters)
                                    " If we have some previous buffer data, then stop any jobs currently
                                    " running and clear everything.
                                    if has_key(g:ale_buffer_info, l:buffer)
                                        call ale#engine#RunLinters(l:buffer, [], 1)
                                    endif
                            
                                    return
                                endif
                            
   13              0.000029     if a:delay > 0
   13              0.000050         let s:queued_buffer_number = l:buffer
   13              0.000139         let s:lint_timer = timer_start(a:delay, function('ale#Lint'))
   13              0.000017     else
                                    call ale#Lint(-1, l:buffer)
                                endif

FUNCTION  <SNR>80_moves_forward()
Called 46 times
Total time:   0.000438
 Self time:   0.000438

count  total (s)   self (s)
   46              0.000159     if a:p[0] != a:n[0]
                                    return a:p[0] < a:n[0]
                                endif
                            
   46              0.000077     if a:p[1] != a:n[1]
   46              0.000074         return a:p[1] < a:n[1]
                                endif
                            
                                return 0

FUNCTION  ale#engine#IsExecutable()
Called 11 times
Total time:   0.000390
 Self time:   0.000390

count  total (s)   self (s)
   11              0.000062     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                " Check for a cached executable() check.
   11              0.000114     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
   11              0.000043     if l:result isnot v:null
   11              0.000033         return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
                                let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
                                if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
                                endif
                            
                                return l:result

FUNCTION  ale#Escape()
Called 31 times
Total time:   0.001364
 Self time:   0.001364

count  total (s)   self (s)
   31              0.000394     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
                                endif
                            
   31              0.000263     return shellescape (a:str)

FUNCTION  ale#handlers#gcc#HandleGCCFormat()
Called 8 times
Total time:   0.004934
 Self time:   0.002198

count  total (s)   self (s)
                                " Look for lines like the following.
                                "
                                " <stdin>:8:5: warning: conversion lacks type at end of format [-Wformat=]
                                " <stdin>:10:27: error: invalid operands to binary - (have int and char *)
                                " -:189:7: note: $/${} is unnecessary on arithmetic variables. [SC2004]
    8              0.000038     let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):(\d+)?:? ([^:]+): (.+)$'
    8              0.000022     let l:output = []
                            
   16   0.001829   0.000150     for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    " Filter out the pragma errors
    8   0.000327   0.000194         if s:IsHeaderFile(bufname(bufnr('')))&& l:match[5][:len(s:pragma_error) - 1] is# s:pragma_error
                                        continue
                                    endif
                            
                                    " If the 'error type' is a note, make it detail related to
                                    " the previous error parsed in output
    8              0.000048         if l:match[4] is# 'note'
                                        if !empty(l:output)
                                            let l:output[-1]['detail'] =   get(l:output[-1], 'detail', '')   . s:RemoveUnicodeQuotes(l:match[0]) . "\n"
                                        endif
                            
                                        continue
                                    endif
                            
    8   0.001167   0.000243         let l:item = {   'lnum': str2nr(l:match[2]),   'type': (l:match[4] is# 'error' || l:match[4] is# 'fatal error') ? 'E' : 'W',   'text': s:RemoveUnicodeQuotes(l:match[5]),}
                            
    8              0.000052         if !empty(l:match[3])
    8              0.000063             let l:item.col = str2nr(l:match[3])
    8              0.000024         endif
                            
                                    " If the filename is something like <stdin>, <nofile> or -, then
                                    " this is an error for the file we checked.
    8              0.000073         if l:match[1] isnot# '-' && l:match[1][0] isnot# '<'
    8              0.000054             let l:item['filename'] = l:match[1]
    8              0.000011         endif
                            
    8              0.000060         call add(l:output, l:item)
    8              0.000015     endfor
                            
    8              0.000020     return l:output

FUNCTION  <SNR>79_GetCachedExtensionMap()
Called 10 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
   10              0.000043     if empty(s:cached_map)
                                    let s:cached_map = ale#filetypes#LoadExtensionMap()
                                endif
                            
   10              0.000025     return s:cached_map

FUNCTION  <SNR>63_InvokeChain()
Called 21 times
Total time:   3.061603
 Self time:   0.000866

count  total (s)   self (s)
   21   0.010221   0.000390     let l:options = ale#engine#ProcessChain(a:buffer, a:linter, a:chain_index, a:input)
                            
   21   3.051323   0.000418     return s:RunJob(l:options)

FUNCTION  repeat#set()
Called 2 times
Total time:   0.000325
 Self time:   0.000325

count  total (s)   self (s)
    2              0.000020     let g:repeat_sequence = a:sequence
    2              0.000016     let g:repeat_count = a:0 ? a:1 : v:count
    2              0.000011     let g:repeat_tick = b:changedtick
    2              0.000014     augroup repeat_custom_motion
    2              0.000196         autocmd!
    2              0.000049         autocmd CursorMoved <buffer> let g:repeat_tick = b:changedtick | autocmd! repeat_custom_motion
    2              0.000006     augroup END

FUNCTION  <SNR>75_BuildSignMap()
Called 8 times
Total time:   0.003750
 Self time:   0.002424

count  total (s)   self (s)
    8   0.000534   0.000099     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    8              0.000023     if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is type(0) && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
    8              0.000040         let l:selected_grouped_items = a:grouped_items
    8              0.000011     endif
                            
    8              0.000026     let l:sign_map = {}
    8              0.000032     let l:sign_offset = g:ale_sign_offset
                            
   15              0.000077     for [l:line, l:sign_id, l:name] in a:current_sign_list
    7              0.000130         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
    7              0.000027         if l:sign_id > l:sign_offset
    7              0.000027             let l:sign_offset = l:sign_id
    7              0.000010         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
    7              0.000049         call add(l:sign_info.current_id_list, l:sign_id)
    7              0.000045         call add(l:sign_info.current_name_list, l:name)
                            
    7              0.000051         let l:sign_map[l:line] = l:sign_info
    7              0.000012     endfor
                            
   16              0.000059     for l:group in l:selected_grouped_items
    8              0.000045         let l:line = l:group[0].lnum
    8              0.000136         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
    8   0.001004   0.000113         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
    8              0.000033         let l:sign_info.items = l:group
                            
    8              0.000067         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
    8              0.000020         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
    3              0.000020             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
    3              0.000005         else
                                        " This sign name replaces the previous name, so use a new ID.
    5              0.000029             let l:sign_info.new_id = l:sign_offset + 1
    5              0.000019             let l:sign_offset += 1
    5              0.000007         endif
                            
    8              0.000050         let l:sign_map[l:line] = l:sign_info
    8              0.000011     endfor
                            
    8              0.000020     return l:sign_map

FUNCTION  GetVimIndent()
Called 42 times
Total time:   0.019303
 Self time:   0.002307

count  total (s)   self (s)
   42              0.000255   let ignorecase_save = &ignorecase
   42              0.000105   try
   42              0.000396     let &ignorecase = 0
   42   0.017628   0.000632     return GetVimIndentIntern()
                              finally
   42              0.000486     let &ignorecase = ignorecase_save
   42              0.000119   endtry

FUNCTION  <SNR>80_getchar()
Called 46 times
Total time:   0.000531
 Self time:   0.000531

count  total (s)   self (s)
   46              0.000093     while 1
   46              0.000147         let cn = getchar()
   46              0.000155         if type(cn) != type('') || cn !=# "\x80\xfd`"
   46              0.000048             return cn
                                    endif
                                endwhile

FUNCTION  <SNR>76_FixList()
Called 8 times
Total time:   0.003480
 Self time:   0.001206

count  total (s)   self (s)
    8   0.000717   0.000136     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    8              0.000035     let l:new_list = []
                            
   16              0.000083     for l:item in a:list
    8              0.000121         let l:fixed_item = copy(l:item)
                            
    8   0.001865   0.000172         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
    8              0.000039         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
    8              0.000082         call add(l:new_list, l:fixed_item)
    8              0.000022     endfor
                            
    8              0.000026     return l:new_list

FUNCTION  <SNR>63_GatherOutput()
Called 8 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    8              0.000032     if has_key(s:job_info_map, a:job_id)
    8              0.000052         call add(s:job_info_map[a:job_id].output, a:line)
    8              0.000006     endif

FUNCTION  <SNR>69_highlight()
Called 6 times
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
    6              0.000021   let s:timer = -1
    6              0.000089   if a:marks !=#  [line("'["), line("']"), col("'["), col("']")]
    6              0.000008     return
                              endif
                              if a:operator !=# 'y' || a:regtype ==# ''
                                return
                              endif
                            
                              let view = winsaveview()
                              let region = s:derive_region(a:regtype, a:regcontents)
                              let maxlinenumber = s:get('max_lines', 10000)
                              if region.tail[1] - region.head[1] + 1 <= maxlinenumber
                                let hi_duration = s:get('highlight_duration', 1000)
                                if hi_duration != 0
                                  call s:glow(region, s:HIGROUP, hi_duration)
                                endif
                              endif
                              call winrestview(view)

FUNCTION  clever_f#find_with()
Called 46 times
Total time:   0.303206
 Self time:   0.298383

count  total (s)   self (s)
   46              0.000395     if a:map !~# '^[fFtT]$'
                                    echoerr 'Invalid mapping: ' . a:map
                                    return ''
                                endif
                            
   46              0.000371     if &foldopen =~# '\<\%(all\|hor\)\>'
   46              0.000156         while foldclosed(line('.')) >= 0
                                        foldopen
                                    endwhile
   46              0.000023     endif
                            
   46              0.000211     let current_pos = getpos('.')[1 : 2]
                            
   46              0.000082     let mode = mode(1)
   46              0.000175     if current_pos != get(s:previous_pos, mode, [0, 0])
   46              0.000089         let back = 0
   46              0.000051         if g:clever_f_mark_cursor
   46              0.000280             let cursor_marker = matchadd('CleverFCursor', '\%#', 999)
   46              0.284229             redraw
   46              0.000061         endif
   46              0.000123         if g:clever_f_hide_cursor_on_cmdline
   46              0.000131             let guicursor_save = &guicursor
   46              0.000374             set guicursor=n:block-NONE
   46              0.000083             let t_ve_save = &t_ve
   46              0.000629             set t_ve=
   46              0.000030         endif
   46              0.000033         try
   46              0.000126             if g:clever_f_show_prompt | echon 'clever-f: ' | endif
   46              0.000134             let s:previous_map[mode] = a:map
   46              0.000075             let s:first_move[mode] = 1
   46   0.000776   0.000246             let cn = s:getchar()
   46              0.000139             if cn == char2nr("\<Esc>")
                                            return "\<Esc>"
                                        endif
   46              0.000418             if index(map(deepcopy(g:clever_f_repeat_last_char_inputs), 'char2nr(v:val)'), cn) == -1
   46              0.000099                 let s:previous_char_num[mode] = cn
   46              0.000027             else
                                            if has_key(s:previous_char_num, s:last_mode)
                                                let s:previous_char_num[mode] = s:previous_char_num[s:last_mode]
                                            else
                                                echohl ErrorMsg | echo 'Previous input not found.' | echohl None
                                                return ''
                                            endif
                                        endif
   46              0.000069             let s:last_mode = mode
                            
   46              0.000060             if g:clever_f_timeout_ms > 0
                                            let s:timestamp = reltime()
                                        endif
                            
   46              0.000065             if g:clever_f_mark_char
   46   0.000943   0.000219                 call s:remove_highlight()
   46              0.000264                 if index(['n', 'v', 'V', "\<C-v>", 's', 'ce'], mode) != -1
   23              0.000042                     augroup plugin-clever-f-finalizer
   23              0.000141                         autocmd CursorMoved <buffer> call s:maybe_finalize()
   23              0.000103                         autocmd InsertEnter <buffer> call s:finalize()
   23              0.000017                     augroup END
   23   0.001818   0.000170                     call s:mark_char_in_current_line(s:previous_map[mode], s:previous_char_num[mode])
   23              0.000014                 endif
   46              0.000023             endif
                            
   46              0.000109             if g:clever_f_show_prompt | redraw! | endif
   46              0.000037         finally
   46              0.000246             if g:clever_f_mark_cursor | call matchdelete(cursor_marker) | endif
   46              0.000049             if g:clever_f_hide_cursor_on_cmdline
   46              0.002393                 set guicursor&
   46              0.002537                 let &guicursor = guicursor_save
   46              0.000568                 let &t_ve = t_ve_save
   46              0.000026             endif
   46              0.000036         endtry
   46              0.000023     else
                                    " when repeated
                                    let back = a:map =~# '\u'
                                    if g:clever_f_fix_key_direction
                                        let back = s:previous_map[mode] =~# '\u' ? !back : back
                                    endif
                            
                                    " reset and retry if timed out
                                    if g:clever_f_timeout_ms > 0 && s:is_timedout()
                                        call clever_f#reset()
                                        return clever_f#find_with(a:map)
                                    endif
                                endif
                            
   46   0.002125   0.000205     return clever_f#repeat(back)

FUNCTION  ale#filetypes#GuessExtension()
Called 10 times
Total time:   0.000449
 Self time:   0.000297

count  total (s)   self (s)
   10   0.000262   0.000110     let l:map = s:GetCachedExtensionMap()
   10              0.000074     let l:ext = get(l:map, a:filetype, '')
                            
                                " If we have an exact match, like something for javascript.jsx, use that.
   10              0.000040     if !empty(l:ext)
   10              0.000026         return l:ext
                                endif
                            
                                " If we don't have an exact match, use the first filetype in the compound
                                " filetype.
                                for l:part in split(a:filetype, '\.')
                                    let l:ext = get(l:map, l:part, '')
                            
                                    if !empty(l:ext)
                                        return l:ext
                                    endif
                                endfor
                            
                                " Return an empty string if we don't find anything.
                                return ''

FUNCTION  <SNR>54_evaluate_range()
Called 62 times
Total time:   0.065571
 Self time:   0.030080

count  total (s)   self (s)
   62              0.000814   let result = { 'range': [], 'pattern': '', 'end': ''}
   62              0.000304   let s:range_valid = 1
   62              0.000671   let pos = s:buf[s:nr].cur_init_pos[0]
                            
  128              0.000707   for specifier in a:range_structure
   66              0.000282     let tmp_pos = pos
   66              0.000323     let specifier_result = []
                            
  132              0.000556     for address in specifier.addresses
                                  " skip empty unclosed pattern specifier when range is empty otherwise
                                  " substitute it with current position
   66              0.001143       if address.address =~# '^[?/]$'
                                    let s:buf[s:nr].show_range = 1
                                    if empty(result.range)
                                      break
                                    endif
                                    let address.address = '.'
                                  endif
   66   0.036904   0.001412       let query = s:spec_to_abs(address, tmp_pos)
                                  " % specifier doesn't accept additional addresses
   66              0.000781       if !query.valid || len(query.range) == 2 && len(specifier.addresses) > 1
                                    let s:range_valid = 0
                                    break
                                  endif
   66              0.000473       let tmp_pos = query.range[-1]
   66              0.000648       let specifier_result = deepcopy(query.range)
   66              0.000365       let result.pattern = query.regex
   66              0.000171     endfor
   66              0.000260     if !s:range_valid
                                  break
                                endif
                            
   66              0.000570     call extend(result.range, specifier_result)
   66              0.000605     if get(specifier, 'delimiter') is# ';'
                                  let pos = result.range[-1]
                                endif
   66              0.000151   endfor
                            
   62              0.000388   if !empty(result.range)
   33              0.000210     let result.end = result.range[-1]
   33              0.000178     if len(result.range) == 1
                                  call extend(result.range, result.range)
                                else
   33              0.000310       let result.range = result.range[-2:-1]
   33              0.000212       if result.range[-1] < result.range[-2]
                                    let temp = result.range[-2]
                                    let result.range[-2] = result.range[-1]
                                    let result.range[-1] = temp
                                  endif
   33              0.000062     endif
   33              0.000057   endif
                            
   62              0.000514   return s:range_valid ? result : { 'range': [], 'pattern': '', 'end': '' }

FUNCTION  <SNR>54_parse_range()
Called 95 times
Total time:   0.108949
 Self time:   0.062671

count  total (s)   self (s)
   95              0.000530   let specifier = {}
   95              0.000560   let specifier.addresses = []
                            
   95              0.000409   let while_limit = 0
  161              0.000576   while 1
                                " address part
  161   0.009376   0.002457     call s:trim(a:cmdl)
  161              0.000754     let entry = {}
                                " regexp for pattern specifier
  161              0.000908     let pattern = '/%(\\.|/@!&.)*/=|\?%(\\.|\?@!&.)*\?='
  161              0.001177     if !len(specifier.addresses)
                                  " \& is not supported
   95              0.005407       let address = matchstrpos(a:cmdl[0], '\v^%(\d+|\.|\$|\%|\*|''.|'. pattern . '|\\\/|\\\?)')
   95              0.000250     else
   66              0.002637       let address = matchstrpos(a:cmdl[0], '\v^%(' . pattern . ')' )
   66              0.000154     endif
  161              0.000904     if address[2] != -1
   66   0.003132   0.001161       call s:trim(a:cmdl, address[2])
   66              0.000519       let entry.address = address[0]
   66              0.000134     endif
                            
                                " offset
  161   0.008451   0.002204     call s:trim(a:cmdl)
  161              0.004862     let offset = matchstrpos(a:cmdl[0], '\m^\%(\d\|\s\|+\|-\)\+')
  161              0.001056     if offset[2] != -1
                                  call s:trim(a:cmdl, offset[2])
                                  let entry.offset = offset[0]
                                endif
                            
                                " add first address
  161              0.001073     if address[2] != -1 || offset[2] != -1
                                  " if offset is present but specifier is missing add '.' specifier
   66              0.000550       if !has_key(entry, 'address')
                                    let entry.address = '.'
                                  endif
   66              0.000586       call add(specifier.addresses, entry)
   66              0.000133     else
                                  " stop trying if previous attempt was unsuccessful
   95              0.000263       break
                                endif
   66              0.001268     let while_limit += 1 | if while_limit == 1000 | echoerr 'infinite loop' | break | endif
   66              0.000185   endwhile
                            
                              " delimiter
   95   0.004990   0.001307   call s:trim(a:cmdl)
   95              0.002589   let delimiter = matchstrpos(a:cmdl[0], '\m^\%(,\|;\)')
   95              0.000526   if delimiter[2] != -1
   33   0.001516   0.000546     call s:trim(a:cmdl, delimiter[2])
   33              0.000288     let specifier.delimiter = delimiter[0]
   33              0.000069   endif
                            
                              " add when addresses or delimiter are found or when one specifier is
                              " already known
   95              0.001243   if !empty(specifier.addresses) || delimiter[2] != -1 || !empty(a:range)
                                " specifiers are not given but delimiter is present
   66              0.000376     if empty(specifier.addresses)
                                  call add(specifier.addresses, { 'address': '.' })
                                endif
   66              0.000500     call add(a:range, specifier)
   66              0.000113   endif
                            
   95              0.000411   if delimiter[2] != -1
   33              0.000082     try
   33              0.000460       return s:parse_range(a:range, a:cmdl)
                                catch /^Vim\%((\a\+)\)\=:E132/
                                  return []
                                endtry
                              else
   62              0.000258     return a:range
                              endif

FUNCTION  <SNR>54_adjust_cmdheight()
Called 2 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
    2              0.000035   let len = strwidth(strtrans(a:cmdl)) + 2
    2              0.000010   let col = &columns
    2              0.000009   let height = &cmdheight
    2              0.000011   if col * height < len
                                noautocmd let &cmdheight=(len / col) + 1
                                redraw
                              elseif col * (height - 1) >= len && height > s:buf[s:nr].cmdheight
                                noautocmd let &cmdheight=max([(len / col), s:buf[s:nr].cmdheight])
                                redraw
                              endif

FUNCTION  ale#util#BinarySearch()
Called 129 times
Total time:   0.010405
 Self time:   0.010405

count  total (s)   self (s)
  129              0.000264     let l:min = 0
  129              0.000584     let l:max = len(a:loclist) - 1
                            
  208              0.000385     while 1
  208              0.000495         if l:max < l:min
  121              0.000199             return -1
                                    endif
                            
   87              0.000325         let l:mid = (l:min + l:max) / 2
   87              0.000319         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
   87              0.000244         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
   67              0.000184             let l:min = l:mid + 1
   67              0.000140         elseif l:item.lnum > a:line
   12              0.000038             let l:max = l:mid - 1
   12              0.000017         else
                                        " This part is a small sequential search.
    8              0.000022             let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
    8              0.000046             while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
    8              0.000048             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
    8              0.000041             let l:item_column = a:loclist[l:index].col
                            
    8              0.000047             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
    8              0.000018             return l:index
                                    endif
   79              0.000104     endwhile

FUNCTION  ale#util#GetItemPriority()
Called 8 times
Total time:   0.000363
 Self time:   0.000363

count  total (s)   self (s)
    8              0.000037     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
                                endif
                            
    8              0.000025     if a:item.type is# 'W'
                                    if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
                                    return g:ale#util#warning_priority
                                endif
                            
    8              0.000050     if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
    8              0.000023     return g:ale#util#error_priority

FUNCTION  ale#cursor#TruncatedEcho()
Called 8 times
Total time:   0.010479
 Self time:   0.009240

count  total (s)   self (s)
    8              0.000030     let l:message = a:original_message
                                " Change tabs to spaces.
    8              0.000089     let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
    8              0.000069     let l:message = substitute(l:message, "\n", '', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
    8              0.000035     let l:shortmess_options = &l:shortmess
                            
    8              0.000011     try
    8              0.000043         let l:cursor_position = getcurpos()
                            
                                    " The message is truncated and saved to the history.
    8              0.000086         setlocal shortmess+=T
    8   0.009710   0.008471         exec "norm! :echomsg l:message\n"
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
    8              0.000093         if l:cursor_position != getcurpos()
                                        call setpos('.', l:cursor_position)
                                    endif
    8              0.000014     finally
    8              0.000099         let &l:shortmess = l:shortmess_options
    8              0.000012     endtry

FUNCTION  ale#engine#RunLinters()
Called 11 times
Total time:   1.635183
 Self time:   0.002576

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
   11   0.000600   0.000197     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
   11   0.002124   0.000216     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
   11   0.000962   0.000232     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
   11   0.000418   0.000177     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
   11              0.000264     silent doautocmd <nomodeline> User ALELintPre
                            
   22              0.000094     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
   11              0.000059         if !l:linter.lint_file || a:should_lint_file
   11   1.629509   0.000185             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
   11              0.000068                 let l:can_clear_results = 0
   11              0.000027             endif
   11              0.000024         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
   11              0.000023     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
   11              0.000041     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
                                elseif l:new_buffer
                                    call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
                                endif

FUNCTION  <SNR>80_maybe_finalize()
Called 41 times
Total time:   0.001090
 Self time:   0.000414

count  total (s)   self (s)
   41              0.000115     let pp = get(s:previous_pos, s:last_mode, [0, 0])
   41              0.000146     if getpos('.')[1 : 2] != pp
   23   0.000752   0.000076         call s:finalize()
   23              0.000012     endif

FUNCTION  <SNR>59_GetAliasedFiletype()
Called 24 times
Total time:   0.002622
 Self time:   0.002622

count  total (s)   self (s)
   24              0.000210     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List.
   24              0.000190     if type(l:buffer_aliases) is type([])
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
   96              0.000466     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
   72              0.000457         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
   72              0.000131     endfor
                            
   24              0.000079     return a:original_filetype

FUNCTION  <SNR>11_get_yankstack_head()
Called 49 times
Total time:   0.004000
 Self time:   0.003115

count  total (s)   self (s)
   49   0.001138   0.000253   let reg = s:default_register()
   49              0.002830   return { 'text': getreg(reg), 'type': getregtype(reg) }

FUNCTION  <SNR>14_inputreplacement()
Called 2 times
Total time:   0.000991
 Self time:   0.000181

count  total (s)   self (s)
    2   0.000858   0.000048   let c = s:getchar()
    2              0.000011   if c == " "
                                let c .= s:getchar()
                              endif
    2              0.000060   if c =~ "\<Esc>" || c =~ "\<C-C>"
                                return ""
                              else
    2              0.000008     return c
                              endif

FUNCTION  <SNR>67_VimCloseCallback()
Called 21 times
Total time:   1.676476
 Self time:   0.004060

count  total (s)   self (s)
   21              0.000498     let l:job = ch_getjob(a:channel)
   21   0.001505   0.000612     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
   21              0.000285     let l:info = get(s:job_map, l:job_id, {})
                            
   21              0.000114     if empty(l:info)
                                    return
                                endif
                            
                                " job_status() can trigger the exit handler.
                                " The channel can close before the job has exited.
   21   0.123718   0.000708     if job_status(l:job) is# 'dead'
   21              0.000044         try
   21              0.000191             if !empty(l:info) && has_key(l:info, 'exit_cb')
   21   1.549163   0.000649                 call ale#util#GetFunction(l:info.exit_cb)(l:job_id, get(l:info, 'exit_code', 1))
   21              0.000028             endif
   21              0.000040         finally
                                        " Automatically forget about the job after it's done.
   21              0.000182             if has_key(s:job_map, l:job_id)
   14              0.000109                 call remove(s:job_map, l:job_id)
   14              0.000017             endif
   21              0.000034         endtry
   21              0.000024     endif

FUNCTION  ale#util#StartPartialTimer()
Called 8 times
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
    8              0.000145     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    8              0.000101     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    8              0.000023     return l:timer_id

FUNCTION  <SNR>63_RunLinter()
Called 11 times
Total time:   1.629324
 Self time:   0.000797

count  total (s)   self (s)
   11              0.000069     if !empty(a:linter.lsp)
                                    return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
                                else
   11   0.001743   0.000172         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
   11   0.000561   0.000171         if ale#engine#IsExecutable(a:buffer, l:executable)
   11   1.626794   0.000228             return s:InvokeChain(a:buffer, a:linter, 0, [])
                                    endif
                                endif
                            
                                return 0

FUNCTION  <SNR>14_getchar()
Called 2 times
Total time:   0.000810
 Self time:   0.000810

count  total (s)   self (s)
    2              0.000638   let c = getchar()
    2              0.000110   if c =~ '^\d\+$'
    2              0.000033     let c = nr2char(c)
    2              0.000007   endif
    2              0.000010   return c

FUNCTION  <SNR>22_MatchInLine()
Called 8 times
Total time:   0.002816
 Self time:   0.002816

count  total (s)   self (s)
    8              0.000041   let line = line('.')
    8              0.000039   let col = col('.')
    8              0.000024   let star_search = 0
                            
    8              0.002017   normal! 0
    8              0.000046   let matches = 0
    8              0.000024   let s_opt = 'c'
                              " The count might be off in edge cases (e.g. regexes that allow empty match,
                              " like 'a*'). Unfortunately, Vim's searching functions are so inconsistent
                              " that I can't fix this.
   16              0.000367   while search(@/, s_opt, line) && col('.') <= col
    8              0.000035     let matches += 1
    8              0.000022     let s_opt = ''
    8              0.000018   endwhile
                            
    8              0.000021   return matches

FUNCTION  ale#highlight#CreatePositions()
Called 8 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    8              0.000028     if a:line >= a:end_line
                                    " For single lines, just return the one position.
    8              0.000079         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  ale_linters#vim#vint#GetCommand()
Called 10 times
Total time:   0.002835
 Self time:   0.000819

count  total (s)   self (s)
   10   0.000734   0.000109     let l:executable = ale_linters#vim#vint#GetExecutable(a:buffer)
   10   0.000622   0.000131     let l:version = ale#semver#GetVersion(l:executable, a:version_output)
                            
   10              0.000105     let l:can_use_no_color_flag = empty(l:version)   || ale#semver#GTE(l:version, [0, 3, 7])
                            
   10   0.000648   0.000134     let l:warning_flag = ale#Var(a:buffer, 'vim_vint_show_style_issues') ? '-s' : '-w'
                            
   10   0.000666   0.000280     return ale#Escape(l:executable)   . ' ' . l:warning_flag   . (l:can_use_no_color_flag ? ' --no-color' : '')   . s:enable_neovim   . ' ' . s:format   . ' %t'

FUNCTION  ale#sign#FindCurrentSigns()
Called 8 times
Total time:   0.003767
 Self time:   0.000233

count  total (s)   self (s)
    8   0.000550   0.000089     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
    8   0.003198   0.000124     return ale#sign#ParseSigns(l:line_list)

FUNCTION  ale#statusline#Update()
Called 8 times
Total time:   0.001532
 Self time:   0.001388

count  total (s)   self (s)
    8              0.000106     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
    8              0.000133     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
    8   0.000256   0.000112     let l:count = s:CreateCountDict()
    8              0.000049     let l:count.total = len(l:loclist)
                            
   16              0.000055     for l:entry in l:loclist
    8              0.000038         if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                                        else
                                            let l:count.warning += 1
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                                    else
    8              0.000026             let l:count.error += 1
    8              0.000012         endif
    8              0.000013     endfor
                            
                                " Set keys for backwards compatibility.
    8              0.000066     let l:count[0] = l:count.error + l:count.style_error
    8              0.000058     let l:count[1] = l:count.total - l:count[0]
                            
    8              0.000069     let g:ale_buffer_info[a:buffer].count = l:count

FUNCTION  <SNR>24_cmdline_changed()
Called 62 times
Total time:   0.008165
 Self time:   0.008165

count  total (s)   self (s)
   62              0.001228   if exists('s:start_init_timer')
   58              0.000669     call timer_stop(s:start_init_timer)
   58              0.000195   endif
   62              0.005572   let s:start_init_timer = timer_start(1, {_-> traces#init(getcmdline(), s:view)})

FUNCTION  <SNR>63_RunJob()
Called 21 times
Total time:   3.050905
 Self time:   0.010212

count  total (s)   self (s)
   21              0.000112     let l:command = a:options.command
   21              0.000089     let l:buffer = a:options.buffer
   21              0.000075     let l:linter = a:options.linter
   21              0.000101     let l:output_stream = a:options.output_stream
   21              0.000103     let l:next_chain_index = a:options.next_chain_index
   21              0.000085     let l:read_buffer = a:options.read_buffer
   21              0.000141     let l:info = g:ale_buffer_info[l:buffer]
                            
   21              0.000106     if empty(l:command)
                                    return 0
                                endif
                            
   21   0.093278   0.000481     let [l:temporary_file, l:command] = ale#command#FormatCommand(l:buffer, l:command, l:read_buffer)
                            
   21   0.184894   0.001907     if s:CreateTemporaryFileForJob(l:buffer, l:temporary_file)
                                    " If a temporary filename has been formatted in to the command, then
                                    " we do not need to send the Vim buffer to the command.
   10              0.000068         let l:read_buffer = 0
   10              0.000019     endif
                            
                                " Add a newline to commands which need it.
                                " This is only used for Flow for now, and is not documented.
   21              0.000087     if l:linter.add_newline
                                    if has('win32')
                                        let l:command = l:command . '; echo.'
                                    else
                                        let l:command = l:command . '; echo'
                                    endif
                                endif
                            
   21   0.002762   0.000397     let l:command = ale#job#PrepareCommand(l:buffer, l:command)
   21              0.000348     let l:job_options = {   'mode': 'nl',   'exit_cb': function('s:HandleExit'),}
                            
   21              0.000100     if l:output_stream is# 'stderr'
   11              0.000153         let l:job_options.err_cb = function('s:GatherOutput')
   11              0.000034     elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput')
                                    let l:job_options.err_cb = function('s:GatherOutput')
                                else
   10              0.000100         let l:job_options.out_cb = function('s:GatherOutput')
   10              0.000011     endif
                            
   21              0.000175     if get(g:, 'ale_run_synchronously') == 1
                                    " Find a unique Job value to use, which will be the same as the ID for
                                    " running commands synchronously. This is only for test code.
                                    let l:job_id = len(s:job_info_map) + 1
                            
                                    while has_key(s:job_info_map, l:job_id)
                                        let l:job_id += 1
                                    endwhile
                                else
   21   2.761362   0.000443         let l:job_id = ale#job#Start(l:command, l:job_options)
   21              0.000021     endif
                            
   21              0.000063     let l:status = 'failed'
                            
                                " Only proceed if the job is being run.
   21              0.000032     if l:job_id
                                    " Add the job to the list of jobs, so we can track them.
   21              0.000219         call add(l:info.job_list, l:job_id)
                            
   21              0.000141         if index(l:info.active_linter_list, l:linter.name) < 0
   21              0.000132             call add(l:info.active_linter_list, l:linter.name)
   21              0.000024         endif
                            
   21              0.000057         let l:status = 'started'
                                    " Store the ID for the job in the map to read back again.
   21              0.000307         let s:job_info_map[l:job_id] = {   'linter': l:linter,   'buffer': l:buffer,   'output': [],   'next_chain_index': l:next_chain_index,}
                            
   21              0.000361         silent doautocmd <nomodeline> User ALEJobStarted
   21              0.000025     endif
                            
   21              0.000054     if g:ale_history_enabled
   21   0.001969   0.000345         call ale#history#Add(l:buffer, l:status, l:job_id, l:command)
   21              0.000035     endif
                            
   21              0.000180     if get(g:, 'ale_run_synchronously') == 1
                                    " Run a command synchronously if this test option is set.
                                    let s:job_info_map[l:job_id].output = systemlist(   type(l:command) == type([])   ?  join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])   : l:command)
                            
                                    call l:job_options.exit_cb(l:job_id, v:shell_error)
                                endif
                            
   21              0.000077     return l:job_id != 0

FUNCTION  ale#Lint()
Called 11 times
Total time:   1.649359
 Self time:   0.002377

count  total (s)   self (s)
   11              0.000204     if a:0 > 1
                                    " Use the buffer number given as the optional second argument.
                                    let l:buffer = a:2
                                elseif a:0 > 0 && a:1 == s:lint_timer
                                    " Use the buffer number for the buffer linting was queued for.
   11              0.000090         let l:buffer = s:queued_buffer_number
   11              0.000026     else
                                    " Use the current buffer number.
                                    let l:buffer = bufnr('')
                                endif
                            
   11   0.003188   0.000179     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                " Use the filetype from the buffer
   11              0.000105     let l:filetype = getbufvar(l:buffer, '&filetype')
   11   0.008237   0.000207     let l:linters = ale#linter#Get(l:filetype)
   11              0.000053     let l:should_lint_file = 0
                            
                                " Check if we previously requested checking the file.
   11              0.000134     if has_key(s:should_lint_file_for_buffer, l:buffer)
                                    unlet s:should_lint_file_for_buffer[l:buffer]
                                    " Lint files if they exist.
                                    let l:should_lint_file = filereadable(expand('#' . l:buffer . ':p'))
                                endif
                            
                                " Apply ignore lists for linters only if needed.
   11   0.000948   0.000189     let l:ignore_config = ale#Var(l:buffer, 'linters_ignore')
   11              0.000160     let l:linters = !empty(l:ignore_config)   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config)   : l:linters
                            
   11   1.635392   0.000208     call ale#engine#RunLinters(l:buffer, l:linters, l:should_lint_file)

FUNCTION  ale#linter#GetAll()
Called 24 times
Total time:   0.001884
 Self time:   0.001884

count  total (s)   self (s)
   24              0.000095     let l:combined_linters = []
                            
   48              0.000171     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
   24              0.000163         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
                                    endif
                            
   24              0.000285         call extend(l:combined_linters, get(s:linters, l:filetype, []))
   24              0.000042     endfor
                            
   24              0.000087     return l:combined_linters

FUNCTION  ale#linter#ResolveFiletype()
Called 24 times
Total time:   0.003370
 Self time:   0.000748

count  total (s)   self (s)
   24   0.003033   0.000412     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
   24              0.000173     if type(l:filetype) != type([])
   24              0.000089         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  ale#engine#RemoveManagedFiles()
Called 8 times
Total time:   0.103119
 Self time:   0.102929

count  total (s)   self (s)
    8              0.000064     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                " We can't delete anything in a sandbox, so wait until we escape from
                                " it to delete temporary files and directories.
    8   0.000256   0.000066     if ale#util#InSandbox()
                                    return
                                endif
                            
                                " Delete files with a call akin to a plan `rm` command.
    8              0.000046     if has_key(l:info, 'temporary_file_list')
    8              0.000035         for l:filename in l:info.temporary_file_list
                                        call delete(l:filename)
                                    endfor
                            
    8              0.000034         let l:info.temporary_file_list = []
    8              0.000009     endif
                            
                                " Delete directories like `rm -rf`.
                                " Directories are handled differently from files, so paths that are
                                " intended to be single files can be set up for automatic deletion without
                                " accidentally deleting entire directories.
    8              0.000046     if has_key(l:info, 'temporary_directory_list')
   18              0.000081         for l:directory in l:info.temporary_directory_list
   10              0.102061             call delete(l:directory, 'rf')
   10              0.000057         endfor
                            
    8              0.000067         let l:info.temporary_directory_list = []
    8              0.000013     endif

FUNCTION  ale#sign#GetSignCommands()
Called 8 times
Total time:   0.001898
 Self time:   0.001898

count  total (s)   self (s)
    8              0.000029     let l:command_list = []
    8              0.000038     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    8              0.000056     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . ' line=1 name=ALEDummySign buffer='   . a:buffer)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
   20              0.000131     for [l:line_str, l:info] in items(a:sign_map)
   12              0.000031         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
   16              0.000045             for l:item in l:info.items
    8              0.000039                 let l:item.sign_id = l:info.new_id
    8              0.000013             endfor
                            
    8              0.000046             if index(l:info.current_id_list, l:info.new_id) < 0
    5              0.000096                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
    5              0.000009             endif
    8              0.000011         endif
   12              0.000015     endfor
                            
                                " Remove signs without new IDs.
   20              0.000082     for l:info in values(a:sign_map)
   19              0.000061         for l:current_id in l:info.current_id_list
    7              0.000028             if l:current_id isnot l:info.new_id
    4              0.000051                 call add(l:command_list, 'sign unplace '   . l:current_id   . ' buffer=' . a:buffer)
    4              0.000006             endif
    7              0.000012         endfor
   12              0.000017     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    8              0.000039     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . ' buffer=' . a:buffer)
                                endif
                            
    8              0.000021     return l:command_list

FUNCTION  <SNR>54_cmdl_enter()
Called 4 times
Total time:   0.001921
 Self time:   0.001425

count  total (s)   self (s)
    4              0.000054   let s:buf[s:nr] = {}
    4              0.000090   let s:buf[s:nr].view = winsaveview()
    4              0.000035   let s:buf[s:nr].show_range = 0
    4              0.000030   let s:buf[s:nr].duration = 0
    4              0.000033   let s:buf[s:nr].hlsearch = &hlsearch
    4              0.000063   let s:buf[s:nr].cword = expand('<cword>')
    4              0.000049   let s:buf[s:nr].cWORD = expand('<cWORD>')
    4              0.000064   let s:buf[s:nr].cfile = expand('<cfile>')
    4              0.000077   let s:buf[s:nr].cur_init_pos = [line('.'), col('.')]
    4              0.000161   let s:buf[s:nr].seq_last = undotree().seq_last
    4              0.000156   let s:buf[s:nr].empty_undotree = empty(undotree().entries)
    4              0.000030   let s:buf[s:nr].changed = 0
    4              0.000034   let s:buf[s:nr].cmdheight = &cmdheight
    4              0.000029   let s:buf[s:nr].redraw = 1
    4              0.000074   let s:buf[s:nr].s_mark = (&encoding == 'utf-8' ? "\uf8b4" : '' )
    4              0.000072   let s:buf[s:nr].winrestcmd = winrestcmd()
    4              0.000080   let s:buf[s:nr].alt_win = win_getid(winnr('#'))
    4              0.000035   let s:buf[s:nr].winwidth = &winwidth
    4              0.000031   let s:buf[s:nr].winheight = &winheight
    4              0.000035   let s:buf[s:nr].pre_cmdl_view = a:view
    4   0.000616   0.000120   call s:save_marks()

FUNCTION  ale#list#SetLists()
Called 8 times
Total time:   0.000760
 Self time:   0.000462

count  total (s)   self (s)
    8              0.000113     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
                                else
    8   0.000497   0.000199         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    8              0.000011     endif

FUNCTION  traces#init()
Called 62 times
Total time:   0.347842
 Self time:   0.088792

count  total (s)   self (s)
   62              0.002385   if &buftype ==# 'terminal' || (has('nvim') && !empty(&inccommand))
                                if exists('s:track_cmdl_timer')
                                  call timer_stop(s:track_cmdl_timer)
                                endif
                                return
                              endif
                            
   62              0.000870   let s:nr =  bufnr('%')
   62              0.000981   if !exists('s:buf[s:nr]')
    4   0.002025   0.000103     call s:cmdl_enter(a:view)
    4              0.000009   endif
                            
   62              0.000338   let s:highlighted = 0
   62              0.000248   let s:moved       = 0
   62              0.000380   let s:last_pattern = @/
                            
   62              0.000590   if s:buf[s:nr].duration < s:timeout
   62              0.000679     let start_time = reltime()
   62              0.000133   endif
                            
   62              0.000427   if s:buf[s:nr].changed
                                let view = winsaveview()
                                noautocmd keepjumps silent undo
                                let s:buf[s:nr].changed = 0
                                let s:highlighted = 1
                                call s:restore_marks()
                                call winrestview(view)
                              endif
   62   0.247711   0.002518   let cmdl = s:evaluate_cmdl([s:skip_modifiers(a:cmdl)])
                            
   62              0.000608   if s:buf[s:nr].duration < s:timeout
                                " range preview
   62              0.001132     if (!empty(cmdl.cmd.name) || s:buf[s:nr].show_range) && !get(s:, 'entire_file')
   37   0.004475   0.000862       call s:highlight('Visual', cmdl.range.pattern, 100)
   37              0.000236       if empty(cmdl.cmd.name)
   10   0.000695   0.000181         call s:highlight('TracesSearch', cmdl.range.specifier, 101)
   10              0.000018       endif
   37   0.003449   0.000655       call s:pos_range(cmdl.range.end, cmdl.range.specifier)
   37              0.000074     endif
                            
                                " cmd preview
   62              0.001381     if cmdl.cmd.name =~# '\v^%(s%[ubstitute]|sm%[agic]|sno%[magic])$'
                                  call s:preview_substitute(cmdl)
                                elseif cmdl.cmd.name =~# '\v^%(g%[lobal]\!=|v%[global])$'
                                  call s:preview_global(cmdl)
                                elseif cmdl.cmd.name =~# '\v^%(sor%[t]\!=)$'
                                  call s:preview_sort(cmdl)
                                endif
                            
                                " clear unnecessary hl
   62              0.000688     if empty(cmdl.range.pattern) || get(s:, 'entire_file')
   29   0.002364   0.000648       call s:highlight('Visual', '', 100)
   29              0.000060     endif
   62              0.001095     if empty(cmdl.cmd.name) && empty(cmdl.range.specifier) || !empty(cmdl.cmd.name) && empty(cmdl.cmd.args)
   62   0.004169   0.001045       call s:highlight('TracesSearch', '', 101)
   62              0.000116     endif
   62              0.000110   endif
                            
                              " move to starting position if necessary
   62              0.001144   if !s:moved && winsaveview() != s:buf[s:nr].view && !wildmenumode()
                                call winrestview(s:buf[s:nr].view)
                              endif
                            
                              " update screen if necessary
   62              0.000211   if s:highlighted
    2   0.000227   0.000051     call s:adjust_cmdheight(a:cmdl)
    2              0.000049     if has('nvim')
                                  redraw
                                else
                                  " https://github.com/markonm/traces.vim/issues/17
                                  " if Vim is missing CmdlineChanged, use explicit redraw only at the
                                  " start of preview or else it is going to be slow
    2              0.000023       if exists('##CmdlineChanged') || s:buf[s:nr].redraw
    2              0.047839         redraw
    2              0.000025         let s:buf[s:nr].redraw = 0
    2              0.000005       else
                                    call winline()
                                  endif
                                  " after patch 8.0.1449, necessary for linux cui, otherwise highlighting
                                  " is not drawn properly, fixed by 8.0.1476
    2              0.000049       if has('unix') && !has('gui_running') && has("patch-8.0.1449") && !has("patch-8.0.1476")
                                    silent! call feedkeys("\<left>\<right>", 'tn')
                                  endif
    2              0.000003     endif
    2              0.000003   endif
                            
   62              0.000454   if exists('start_time')
   62              0.001351     let s:buf[s:nr].duration = reltimefloat(reltime(start_time)) * 1000
   62              0.000128   endif

FUNCTION  ale#util#InSandbox()
Called 187 times
Total time:   0.004050
 Self time:   0.004050

count  total (s)   self (s)
  187              0.000318     try
  187              0.000900         function! s:SandboxCheck() abort
                                    endfunction
  187              0.000578     catch /^Vim\%((\a\+)\)\=:E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
  187              0.000286     return 0

FUNCTION  ale#path#Simplify()
Called 9 times
Total time:   0.000649
 Self time:   0.000649

count  total (s)   self (s)
    9              0.000165     if has('unix')
                                    return substitute(simplify(a:path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
    9              0.000145     let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
    9              0.000188     return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  <SNR>14_reindent()
Called 2 times
Total time:   0.019754
 Self time:   0.001683

count  total (s)   self (s)
    2              0.000042   if exists("b:surround_indent") ? b:surround_indent : (!exists("g:surround_indent") || g:surround_indent)
    2   0.019695   0.001624     silent norm! '[=']
    2              0.000008   endif

FUNCTION  <SNR>75_GroupLoclistItems()
Called 8 times
Total time:   0.000686
 Self time:   0.000686

count  total (s)   self (s)
    8              0.000031     let l:grouped_items = []
    8              0.000025     let l:last_lnum = -1
                            
   16              0.000066     for l:obj in a:loclist
    8              0.000027         if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
    8              0.000028         if l:obj.lnum != l:last_lnum
    8              0.000045             call add(l:grouped_items, [])
    8              0.000010         endif
                            
    8              0.000058         call add(l:grouped_items[-1], l:obj)
    8              0.000029         let l:last_lnum = l:obj.lnum
    8              0.000014     endfor
                            
    8              0.000023     return l:grouped_items

FUNCTION  ale#util#GetLineCount()
Called 8 times
Total time:   0.003720
 Self time:   0.003720

count  total (s)   self (s)
    8              0.003711     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  ale#engine#FixLocList()
Called 8 times
Total time:   0.017119
 Self time:   0.007230

count  total (s)   self (s)
    8              0.000031     let l:bufnr_map = {}
    8              0.000026     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    8   0.003838   0.000118     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
   16              0.000059     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
    8              0.000318         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
    8              0.000043         if has_key(l:old_item, 'code')
                                        let l:item.code = l:old_item.code
                                    endif
                            
    8   0.008558   0.002841         if has_key(l:old_item, 'filename')&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_item.filename
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
    8              0.000039         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
    8              0.000038         if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
                                    endif
                            
    8              0.000038         if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                    endif
                            
    8              0.000035         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
    8              0.000026         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
    8              0.000052         call add(l:new_loclist, l:item)
    8              0.000014     endfor
                            
    8   0.000595   0.000142     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    8              0.000134     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
    8              0.000022     return l:new_loclist

FUNCTION  <SNR>41_Highlight_Matching_Pair()
Called 210 times
Total time:   0.037446
 Self time:   0.037446

count  total (s)   self (s)
                              " Remove any previous match.
  210              0.001405   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  210              0.004076   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  210              0.001071   let c_lnum = line('.')
  210              0.000882   let c_col = col('.')
  210              0.000418   let before = 0
                            
  210              0.000965   let text = getline(c_lnum)
  210              0.007060   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  210              0.000817   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  210              0.001772     let [c_before, c] = matches[1:2]
  210              0.000233   endif
  210              0.006055   let plist = split(&matchpairs, '.\zs[:,]')
  210              0.001243   let i = index(plist, c)
  210              0.000400   if i < 0
                                " not found, in Insert mode try character before the cursor
  210              0.001338     if c_col > 1 && (mode() == 'i' || mode() == 'R')
    4              0.000027       let before = strlen(c_before)
    4              0.000012       let c = c_before
    4              0.000022       let i = index(plist, c)
    4              0.000006     endif
  210              0.000329     if i < 0
                                  " not found, nothing to do
  210              0.000421       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  LinterStatus()
Called 311 times
Total time:   0.029415
 Self time:   0.011638

count  total (s)   self (s)
  311   0.022789   0.005012     let l:counts = ale#statusline#Count(bufnr(''))
  311              0.001574     let l:all_errors = l:counts.error + l:counts.style_error
  311              0.001308     let l:all_non_errors = l:counts.total - l:all_errors
                            
  311              0.002504     return l:counts.total == 0 ? 'OK' : printf(   '%dW %dE',   all_non_errors,   all_errors)

FUNCTION  <SNR>16_check_buffer_changes()
Called 13 times
Total time:   0.000422
 Self time:   0.000422

count  total (s)   self (s)
   13              0.000096     let bufnum = bufnr('%')
   13              0.000109     let old_modified_flag = getbufvar(bufnum, "vem_tabline_mod_opt")
   13              0.000046     if old_modified_flag != &modified
                                    call g:vem_tabline#tabline.refresh()
                                    call setbufvar(bufnum, 'vem_tabline_mod_opt', &modified)
                                endif

FUNCTION  ale#highlight#SetHighlights()
Called 8 times
Total time:   0.002996
 Self time:   0.000445

count  total (s)   self (s)
    8              0.000172     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    8              0.000127     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    8   0.002642   0.000091     call ale#highlight#UpdateHighlights()

FUNCTION  ale#engine#SetResults()
Called 8 times
Total time:   0.197890
 Self time:   0.001787

count  total (s)   self (s)
    8   0.000285   0.000118     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    8              0.000024     if g:ale_set_signs
    8   0.085698   0.000185         call ale#sign#SetSigns(a:buffer, a:loclist)
    8              0.000011     endif
                            
    8              0.000034     if g:ale_set_quickfix || g:ale_set_loclist
    8   0.000890   0.000130         call ale#list#SetLists(a:buffer, a:loclist)
    8              0.000009     endif
                            
    8              0.000056     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
    8   0.001640   0.000108         call ale#statusline#Update(a:buffer, a:loclist)
    8              0.000010     endif
                            
    8              0.000023     if g:ale_set_highlights
    8   0.003094   0.000098         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    8              0.000011     endif
                            
    8              0.000022     if l:linting_is_done
    8              0.000019         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    8   0.002097   0.000081             call ale#cursor#EchoCursorWarning()
    8              0.000011         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    8              0.000069         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    8              0.000095         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    8   0.103229   0.000110         call ale#engine#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    8              0.000202         silent doautocmd <nomodeline> User ALELintPost
                                    " remove in 2.0
                                    " Old DEPRECATED name; call it for backwards compatibility.
    8              0.000074         silent doautocmd <nomodeline> User ALELint
    8              0.000011     endif

FUNCTION  <SNR>76_ShouldOpen()
Called 16 times
Total time:   0.001465
 Self time:   0.000517

count  total (s)   self (s)
   16   0.001166   0.000217     let l:val = ale#Var(a:buffer, 'open_list')
   16              0.000143     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
   16              0.000106     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  <SNR>80_remove_highlight()
Called 69 times
Total time:   0.000906
 Self time:   0.000906

count  total (s)   self (s)
   92              0.000586     for h in filter(getmatches(), 'v:val.group ==# "CleverFChar"')
   23              0.000062         call matchdelete(h.id)
   23              0.000018     endfor

FUNCTION  <SNR>11_before_yank()
Called 49 times
Total time:   0.005310
 Self time:   0.001310

count  total (s)   self (s)
   49   0.004282   0.000282   let head = s:get_yankstack_head()
   49              0.000401   if !empty(head.text) && (empty(s:yankstack_tail) || (head != s:yankstack_tail[0]))
   48              0.000122     call insert(s:yankstack_tail, head)
   48              0.000383     let s:yankstack_tail = s:yankstack_tail[: g:yankstack_size-1]
   48              0.000029   endif

FUNCTION  ale#util#GetMatches()
Called 8 times
Total time:   0.001679
 Self time:   0.001679

count  total (s)   self (s)
    8              0.000023     let l:matches = []
    8              0.000067     let l:lines = type(a:lines) == type([]) ? a:lines : [a:lines]
    8              0.000083     let l:patterns = type(a:patterns) == type([]) ? a:patterns : [a:patterns]
                            
   16              0.000057     for l:line in l:lines
    8              0.000035         for l:pattern in l:patterns
    8              0.000962             let l:match = matchlist(l:line, l:pattern)
                            
    8              0.000045             if !empty(l:match)
    8              0.000049                 call add(l:matches, l:match)
    8              0.000019                 break
                                        endif
                                    endfor
    8              0.000014     endfor
                            
    8              0.000022     return l:matches

FUNCTION  clever_f#find()
Called 46 times
Total time:   0.007152
 Self time:   0.001982

count  total (s)   self (s)
   46              0.000203     let before_pos = getpos('.')[1 : 2]
   46   0.005038   0.000306     let next_pos = s:next_pos(a:map, a:char_num, v:count1)
   46              0.000118     if next_pos == [0, 0]
                                    return
                                endif
                            
   46   0.000678   0.000240     let moves_forward = s:moves_forward(before_pos, next_pos)
                            
                                " update highlight when cursor moves across lines
   46              0.000098     let mode = mode(1)
   46              0.000043     if g:clever_f_mark_char
   46              0.000213         if next_pos[0] != before_pos[0] || (a:map ==? 't' && !s:first_move[mode] && clever_f#compat#xor(s:moved_forward, moves_forward))
                                        call s:remove_highlight()
                                        call s:mark_char_in_current_line(a:map, a:char_num)
                                    endif
   46              0.000022     endif
                            
   46              0.000068     let s:moved_forward = moves_forward
   46              0.000129     let s:previous_pos[mode] = next_pos
   46              0.000066     let s:first_move[mode] = 0

FUNCTION  <SNR>63_CreateTemporaryFileForJob()
Called 21 times
Total time:   0.182987
 Self time:   0.010947

count  total (s)   self (s)
   21              0.000113     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
   11              0.000028         return 0
                                endif
                            
   10              0.000107     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
   10              0.006976     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
   10   0.000967   0.000287     call ale#engine#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
   10              0.002865     let l:lines = getbufline(a:buffer, 1, '$')
   10   0.171588   0.000228     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
   10              0.000074     return 1

FUNCTION  ale#engine#HandleLoclist()
Called 8 times
Total time:   0.217822
 Self time:   0.001195

count  total (s)   self (s)
    8              0.000082     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    8              0.000040     if empty(l:info)
                                    return
                                endif
                            
                                " Remove this linter from the list of active linters.
                                " This may have already been done when the job exits.
    8              0.000096     call filter(l:info.active_linter_list, 'v:val isnot# a:linter_name')
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    8   0.017265   0.000146     let l:linter_loclist = ale#engine#FixLocList(a:buffer, a:linter_name, a:loclist)
                            
                                " Remove previous items for this linter.
    8              0.000098     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    8              0.000039     if !empty(l:linter_loclist)
                                    " Add the new items.
    8              0.000049         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    8              0.000058         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    8              0.000015     endif
                            
    8   0.001784   0.000166     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
    8   0.198002   0.000112     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  <SNR>22_MatchesInRange()
Called 9 times
Total time:   0.002605
 Self time:   0.002605

count  total (s)   self (s)
                              " Use :s///n to search efficiently in large files. Although calling search()
                              " in the loop would be cleaner (see issue #18), it is also much slower.
    9              0.000032   let gflag = &gdefault ? '' : 'g'
    9              0.000113   let saved_marks = [ getpos("'["), getpos("']") ]
    9              0.000020   let output = ''
    9              0.000046   redir => output
    9              0.001917     silent! execute 'keepjumps ' . a:range . 's///en' . gflag
    9              0.000060   redir END
    9              0.000116   call setpos("'[", saved_marks[0])
    9              0.000048   call setpos("']", saved_marks[1])
    9              0.000193   return str2nr(matchstr(output, '\d\+'))

FUNCTION  <SNR>63_StopCurrentJobs()
Called 11 times
Total time:   0.001908
 Self time:   0.001504

count  total (s)   self (s)
   11              0.000114     let l:info = get(g:ale_buffer_info, a:buffer, {})
   11              0.000046     let l:new_job_list = []
   11              0.000053     let l:new_active_linter_list = []
                            
   14              0.000120     for l:job_id in get(l:info, 'job_list', [])
    3              0.000010         let l:job_info = get(s:job_info_map, l:job_id, {})
                            
    3              0.000005         if !empty(l:job_info)
    3              0.000007             if a:include_lint_file_jobs || !l:job_info.linter.lint_file
    3   0.000419   0.000015                 call ale#job#Stop(l:job_id)
    3              0.000018                 call remove(s:job_info_map, l:job_id)
    3              0.000004             else
                                            call add(l:new_job_list, l:job_id)
                                            " Linters with jobs still running are still active.
                                            call add(l:new_active_linter_list, l:job_info.linter.name)
                                        endif
    3              0.000003         endif
    3              0.000004     endfor
                            
                                " Remove duplicates from the active linter list.
   11              0.000131     call uniq(sort(l:new_active_linter_list))
                            
                                " Update the List, so it includes only the jobs we still need.
   11              0.000071     let l:info.job_list = l:new_job_list
                                " Update the active linter list, clearing out anything not running.
   11              0.000070     let l:info.active_linter_list = l:new_active_linter_list

FUNCTION  <SNR>54_get_command()
Called 62 times
Total time:   0.054536
 Self time:   0.050772

count  total (s)   self (s)
   62   0.003723   0.000871   call s:trim(a:cmdl)
   62              0.000227   if !s:range_valid
                                return ''
                              endif
   62              0.046896   let result = matchstrpos(a:cmdl[0], s:cmd_pattern)
   62              0.000718   if result[2] != -1
   27   0.001479   0.000566     call s:trim(a:cmdl, result[2])
   27              0.000147     return result[0]
                              endif
   35              0.000118   return ''

FUNCTION  <SNR>11_yank_with_key()
Called 49 times
Total time:   0.005697
 Self time:   0.000387

count  total (s)   self (s)
   49   0.005588   0.000279   call s:before_yank()
   49              0.000071   return a:key

FUNCTION  ale#history#Get()
Called 26 times
Total time:   0.000446
 Self time:   0.000446

count  total (s)   self (s)
   26              0.000427     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  <SNR>63_HandleExit()
Called 28 times
Total time:   1.669251
 Self time:   0.003776

count  total (s)   self (s)
   28              0.000196     if !has_key(s:job_info_map, a:job_id)
   10              0.000016         return
                                endif
                            
   18              0.000122     let l:job_info = s:job_info_map[a:job_id]
   18              0.000076     let l:linter = l:job_info.linter
   18              0.000075     let l:output = l:job_info.output
   18              0.000060     let l:buffer = l:job_info.buffer
   18              0.000083     let l:next_chain_index = l:job_info.next_chain_index
                            
   18              0.000059     if g:ale_history_enabled
   18   0.001724   0.000245         call ale#history#SetExitCode(l:buffer, a:job_id, a:exit_code)
   18              0.000025     endif
                            
                                " Remove this job from the list.
   18   0.003000   0.000178     call ale#job#Stop(a:job_id)
   18              0.000131     call remove(s:job_info_map, a:job_id)
   18              0.000263     call filter(g:ale_buffer_info[l:buffer].job_list, 'v:val isnot# a:job_id')
   18              0.000219     call filter(g:ale_buffer_info[l:buffer].active_linter_list, 'v:val isnot# l:linter.name')
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
   18   0.000566   0.000152     if ale#util#InSandbox()
                                    return
                                endif
                            
   18              0.000337     if has('nvim') && !empty(l:output) && empty(l:output[-1])
                                    call remove(l:output, -1)
                                endif
                            
   18              0.000169     if l:next_chain_index < len(get(l:linter, 'command_chain', []))
   10   1.435211   0.000174         call s:InvokeChain(l:buffer, l:linter, l:next_chain_index, l:output)
   10              0.000019         return
                                endif
                            
                                " Log the output of the command for ALEInfo if we should.
    8              0.000037     if g:ale_history_enabled && g:ale_history_log_output
    8   0.000618   0.000115         call ale#history#RememberOutput(l:buffer, a:job_id, l:output[:])
    8              0.000010     endif
                            
    8   0.007571   0.000174     let l:loclist = ale#util#GetFunction(l:linter.callback)(l:buffer, l:output)
                            
    8   0.217967   0.000145     call ale#engine#HandleLoclist(l:linter.name, l:buffer, l:loclist)

FUNCTION  <SNR>54_restore_undo_history()
Called 4 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
    4              0.000009   if s:buf[s:nr].changed
                                noautocmd keepjumps silent undo
                                call s:restore_marks()
                              endif
                            
    4              0.000024   if type(get(s:buf[s:nr], 'undo_file')) isnot v:t_string
    4              0.000005     return
                              endif
                            
                              if has('nvim')
                                " can't use try/catch on Neovim inside CmdlineLeave
                                " https://github.com/neovim/neovim/issues/7876
                                silent! execute 'noautocmd rundo ' . s:buf[s:nr].undo_file
                                if undotree().seq_last !=# s:buf[s:nr].seq_last
                                  echohl WarningMsg
                                  echom 'traces.vim - undo history could not be restored'
                                  echohl None
                                endif
                              else
                                try
                                  silent execute 'noautocmd rundo ' . s:buf[s:nr].undo_file
                                catch
                                  echohl WarningMsg
                                  echom 'traces.vim - ' . v:exception
                                  echohl None
                                endtry
                              endif
                              call delete(s:buf[s:nr].undo_file)

FUNCTION  <SNR>54_trim()
Called 605 times
Total time:   0.023552
 Self time:   0.023552

count  total (s)   self (s)
  605              0.002050   if a:0 == 2
  126              0.001600     let a:1[0] = strcharpart(a:1[0], a:2)
  126              0.000291   else
  479              0.011459     let a:1[0] = substitute(a:1[0], '^\s\+', '', '')
  479              0.001041   endif

FUNCTION  ale#path#IsTempName()
Called 8 times
Total time:   0.000817
 Self time:   0.000213

count  total (s)   self (s)
    8   0.000809   0.000206     return ale#path#Simplify(a:filename)[:len(s:temp_dir) - 1] is# s:temp_dir

FUNCTION  ale#semver#GetVersion()
Called 10 times
Total time:   0.000491
 Self time:   0.000491

count  total (s)   self (s)
   10              0.000068     let l:version = get(s:version_cache, a:executable, [])
                            
   10              0.000052     for l:line in a:version_lines
                                    let l:match = matchlist(l:line, '\v(\d+)\.(\d+)\.(\d+)')
                            
                                    if !empty(l:match)
                                        let l:version = [l:match[1] + 0, l:match[2] + 0, l:match[3] + 0]
                                        let s:version_cache[a:executable] = l:version
                            
                                        break
                                    endif
                                endfor
                            
   10              0.000029     return l:version

FUNCTION  ale#history#Add()
Called 21 times
Total time:   0.001625
 Self time:   0.001625

count  total (s)   self (s)
   21              0.000084     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
   21              0.000277     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   21              0.000117     if len(l:history) >= g:ale_max_buffer_history_size
    3              0.000037         let l:history = l:history[1:]
    3              0.000005     endif
                            
   21              0.000276     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   21              0.000257     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  <SNR>80_next_pos()
Called 46 times
Total time:   0.004732
 Self time:   0.002008

count  total (s)   self (s)
   46              0.000084     let mode = mode(1)
   46              0.000260     let search_flag = a:map =~# '\l' ? 'W' : 'bW'
   46              0.000054     let cnt = a:count
   46   0.002492   0.000238     let pattern = s:generate_pattern(a:map, a:char_num)
                            
   46              0.000114     if a:map ==? 't' && get(s:first_move, mode, 1)
   18   0.000335   0.000103         if !s:search(pattern, search_flag . 'c')
                                        return [0, 0]
                                    endif
   18              0.000023         let cnt -= 1
   18              0.000010     endif
                            
   74              0.000083     while 0 < cnt
   28   0.000376   0.000137         if !s:search(pattern, search_flag)
                                        return [0, 0]
                                    endif
   28              0.000057         let cnt -= 1
   28              0.000021     endwhile
                            
   46              0.000178     return getpos('.')[1 : 2]

FUNCTION  <SNR>59_GetLinterNames()
Called 24 times
Total time:   0.002091
 Self time:   0.002091

count  total (s)   self (s)
   24              0.000193     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
   24              0.000094     if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
   24              0.000159     if type(l:buffer_ale_linters) is type([])
                                    return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
   24              0.000147     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
   24              0.000156     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
   24              0.000074     if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
   24              0.000148     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
   24              0.000051     return 'all'

FUNCTION  ale#linter#GetExecutable()
Called 11 times
Total time:   0.001571
 Self time:   0.000382

count  total (s)   self (s)
   11   0.001555   0.000366     return has_key(a:linter, 'executable_callback')   ? ale#util#GetFunction(a:linter.executable_callback)(a:buffer)   : a:linter.executable

FUNCTION  <SNR>54_evaluate_cmdl()
Called 62 times
Total time:   0.222148
 Self time:   0.010024

count  total (s)   self (s)
   62              0.000391   let cmdl                 = {}
   62              0.000519   let cmdl.string          = a:string
   62   0.149143   0.002790   let r                    = s:evaluate_range(s:parse_range([], cmdl.string))
   62              0.000376   let cmdl.range           = {}
   62              0.000399   let cmdl.range.abs       = r.range
   62              0.000335   let cmdl.range.end       = r.end
   62   0.003918   0.001265   let cmdl.range.pattern   = s:get_selection_regexp(r.range)
   62   0.002041   0.001260   let cmdl.range.specifier = s:add_flags(r.pattern, cmdl, 3)
                            
   62              0.000319   let cmdl.cmd             = {}
   62              0.000334   let cmdl.cmd.args        = {}
   62   0.063335   0.000998   call s:parse_command(cmdl)
                            
   62              0.000231   return cmdl

FUNCTION  ale#job#PrepareCommand()
Called 21 times
Total time:   0.002365
 Self time:   0.001096

count  total (s)   self (s)
   21   0.001555   0.000286     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
   21              0.000298     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
   21              0.000106     if has('win32')
   21              0.000136         return 'cmd /s/c "' . l:command . '"'
                                endif
                            
                                if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
                                endif
                            
                                return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  ale#util#GetFunction()
Called 76 times
Total time:   0.001433
 Self time:   0.001433

count  total (s)   self (s)
   76              0.000649     if type(a:string_or_ref) == type('')
   40              0.000291         return function(a:string_or_ref)
                                endif
                            
   36              0.000106     return a:string_or_ref

FUNCTION  <SNR>54_spec_to_abs()
Called 66 times
Total time:   0.035492
 Self time:   0.035492

count  total (s)   self (s)
   66              0.000298   let result = {}
   66              0.000337   let result.range = []
   66              0.000279   let result.valid = 1
   66              0.000267   let result.regex = ''
   66              0.000276   let s:entire_file  = 0
                            
   66              0.000885   if     a:address.address =~# '^\d\+'
                                let lnum = str2nr(a:address.address)
                                call add(result.range, lnum)
                            
                              elseif a:address.address ==# '.'
                                call add(result.range, a:last_position)
                            
                              elseif a:address.address ==# '$'
                                call add(result.range, getpos('$')[1])
                            
                              elseif a:address.address ==# '%'
                                call add(result.range, 1)
                                call add(result.range, getpos('$')[1])
                                let s:entire_file = 1
                            
                              elseif a:address.address ==# '*'
                                call add(result.range, getpos('''<')[1])
                                call add(result.range, getpos('''>')[1])
                                if match(&cpoptions, '\*') != -1
                                  let result.valid = 0
                                endif
                                let s:buf[s:nr].show_range = 1
                            
                              elseif a:address.address =~# '^''.'
   66              0.000649     call cursor(a:last_position, 1)
   66              0.000798     let mark_position = getpos(a:address.address)
   66              0.000435     if mark_position[1]
   66              0.000616       call add(result.range, mark_position[1])
   66              0.000135     else
                                  let result.valid = 0
                                endif
   66              0.000513     let s:buf[s:nr].show_range = 1
                            
   66              0.000260   elseif a:address.address =~# '\v^\/%(\\.|.){-}%([^\\]\\)@<!\/$'
                                let pattern = a:address.address[1:-2]
                                if empty(pattern)
                                  let pattern = s:last_pattern
                                else
                                  let s:last_pattern = pattern
                                endif
                                call cursor(a:last_position + 1, 1)
                                let s:buf[s:nr].show_range = 1
                                silent! let query = search(pattern, 'nc', 0, s:s_timeout)
                                if query == 0
                                  let result.valid = 0
                                endif
                                call add(result.range, query)
                            
                              elseif a:address.address =~# '\v^\?%(\\.|.){-}%([^\\]\\)@<!\?$'
                                let pattern = a:address.address[1:-2]
                                let pattern = substitute(pattern, '\\?', '?', '')
                                if empty(pattern)
                                  let pattern = s:last_pattern
                                else
                                  let s:last_pattern = pattern
                                endif
                                call cursor(a:last_position, 1)
                                let s:buf[s:nr].show_range = 1
                                silent! let query = search(pattern, 'nb', 0, s:s_timeout)
                                if query == 0
                                  let result.valid = 0
                                endif
                                call add(result.range, query)
                            
                              elseif a:address.address =~# '^/.*$'
                                let pattern = a:address.address[1:]
                                call cursor(a:last_position + 1, 1)
                                silent! let query = search(pattern, 'nc', 0, s:s_timeout)
                                if !query
                                  let result.valid = 0
                                endif
                                call add(result.range, query)
                                let s:buf[s:nr].show_range = 1
                                let result.regex = pattern
                            
                              elseif a:address.address =~# '^?.*$'
                                let pattern = a:address.address[1:]
                                let pattern = substitute(pattern, '\\?', '?', '')
                                call cursor(a:last_position, 1)
                                silent! let query = search(pattern, 'nb', 0, s:s_timeout)
                                if !query
                                  let result.valid = 0
                                endif
                                call add(result.range, query)
                                let s:buf[s:nr].show_range = 1
                                let result.regex = pattern
                            
                              elseif a:address.address ==# '\/'
                                call cursor(a:last_position + 1, 1)
                                silent! let query = search(s:last_pattern, 'nc', 0, s:s_timeout)
                                if query == 0
                                  let result.valid = 0
                                endif
                                call add(result.range, query)
                                let s:buf[s:nr].show_range = 1
                            
                              elseif a:address.address ==# '\?'
                                call cursor(a:last_position, 1)
                                silent! let query = search(s:last_pattern, 'nb', 0, s:s_timeout)
                                if query == 0
                                  let result.valid = 0
                                endif
                                call add(result.range, query)
                                let s:buf[s:nr].show_range = 1
                              endif
                            
   66              0.000404   if !empty(result.range)
                                " add offset
   66              0.000566     if has_key(a:address, 'offset') && !s:entire_file
                                  let result.range[0] += s:offset_to_num(a:address.offset)
                                endif
                            
                                " treat specifier 0 as 1
   66              0.000347     if result.range[0] == 0
                                  let result.range[0] = 1
                                endif
                            
                                " check if range exceeds file limits
   66              0.000726     if result.range[0] > line('$') || result.range[0] < 0
                                  let result.valid = 0
                                endif
   66              0.000142   endif
                            
   66              0.000216   return result

FUNCTION  <SNR>24_t_start()
Called 71 times
Total time:   0.002333
 Self time:   0.002333

count  total (s)   self (s)
   71              0.000227   if !g:traces_enabled
                                return
                              endif
   71              0.000360   if exists('##CmdlineChanged')
   71              0.000893     let s:track_cmdl_timer = timer_start(30,function('s:create_cmdl_changed_au'))
   71              0.000073   else
                                let s:track_cmdl_timer = timer_start(30,function('s:track_cmdl'),{'repeat':-1})
                              endif

FUNCTION  <SNR>22_PrintMatches()
Called 8 times
Total time:   0.086312
 Self time:   0.078601

count  total (s)   self (s)
    8              0.000068   let l:dir_char = v:searchforward ? '/' : '?'
    8              0.000058   if line('$') > g:searchindex_line_limit
                                let l:msg = '[MAX]  ' . l:dir_char . @/
                              else
                                " If there are no matches, search fails before we get here. The only way
                                " we could see zero results is on 'g/' (but that's a reasonable result).
    8   0.007867   0.000156     let [l:current, l:total] = searchindex#MatchCounts()
    8              0.000088     let l:msg = '[' . l:current . '/' . l:total . ']  ' . l:dir_char . @/
    8              0.000009   endif
                            
                              " foldopen+=search causes search commands to open folds in the matched line
                              " - but it doesn't work in mappings. Hence, we just open the folds here.
    8              0.000073   if &foldopen =~# "search"
    8              0.001603     normal! zv
    8              0.000028   endif
                            
                              " Flush any delayed screen updates before printing "l:msg".
                              " See ":h :echo-redraw".
    8              0.076367   redraw | echo l:msg

FUNCTION  <SNR>14_wrap()
Called 2 times
Total time:   0.002830
 Self time:   0.002116

count  total (s)   self (s)
    2              0.000012   let keeper = a:string
    2              0.000010   let newchar = a:char
    2              0.000009   let s:input = ""
    2              0.000008   let type = a:type
    2              0.000017   let linemode = type ==# 'V' ? 1 : 0
    2              0.000008   let before = ""
    2              0.000008   let after  = ""
    2              0.000009   if type ==# "V"
    2              0.000053     let initspaces = matchstr(keeper,'\%^\s*')
    2              0.000005   else
                                let initspaces = matchstr(getline('.'),'\%^\s*')
                              endif
    2              0.000009   let pairs = "b()B{}r[]a<>"
    2              0.000008   let extraspace = ""
    2              0.000027   if newchar =~ '^ '
                                let newchar = strpart(newchar,1)
                                let extraspace = ' '
                              endif
    2              0.000028   let idx = stridx(pairs,newchar)
    2              0.000017   if newchar == ' '
                                let before = ''
                                let after  = ''
                              elseif exists("b:surround_".char2nr(newchar))
                                let all    = s:process(b:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif exists("g:surround_".char2nr(newchar))
                                let all    = s:process(g:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif newchar ==# "p"
                                let before = "\n"
                                let after  = "\n\n"
                              elseif newchar ==# 's'
                                let before = ' '
                                let after  = ''
                              elseif newchar ==# ':'
                                let before = ':'
                                let after = ''
                              elseif newchar =~# "[tT\<C-T><]"
                                let dounmapp = 0
                                let dounmapb = 0
                                if !maparg(">","c")
                                  let dounmapb = 1
                                  " Hide from AsNeeded
                                  exe "cn"."oremap > ><CR>"
                                endif
                                let default = ""
                                if newchar ==# "T"
                                  if !exists("s:lastdel")
                                    let s:lastdel = ""
                                  endif
                                  let default = matchstr(s:lastdel,'<\zs.\{-\}\ze>')
                                endif
                                let tag = input("<",default)
                                if dounmapb
                                  silent! cunmap >
                                endif
                                let s:input = tag
                                if tag != ""
                                  let keepAttributes = ( match(tag, ">$") == -1 )
                                  let tag = substitute(tag,'>*$','','')
                                  let attributes = ""
                                  if keepAttributes
                                    let attributes = matchstr(a:removed, '<[^ \t\n]\+\zs\_.\{-\}\ze>')
                                  endif
                                  let s:input = tag . '>'
                                  if tag =~ '/$'
                                    let tag = substitute(tag, '/$', '', '')
                                    let before = '<'.tag.attributes.' />'
                                    let after = ''
                                  else
                                    let before = '<'.tag.attributes.'>'
                                    let after  = '</'.substitute(tag,' .*','','').'>'
                                  endif
                                  if newchar == "\<C-T>"
                                    if type ==# "v" || type ==# "V"
                                      let before .= "\n\t"
                                    endif
                                    if type ==# "v"
                                      let after  = "\n". after
                                    endif
                                  endif
                                endif
                              elseif newchar ==# 'l' || newchar == '\'
                                " LaTeX
                                let env = input('\begin{')
                                if env != ""
                                  let s:input = env."\<CR>"
                                  let env = '{' . env
                                  let env .= s:closematch(env)
                                  echo '\begin'.env
                                  let before = '\begin'.env
                                  let after  = '\end'.matchstr(env,'[^}]*').'}'
                                endif
                              elseif newchar ==# 'f' || newchar ==# 'F'
                                let fnc = input('function: ')
                                if fnc != ""
                                  let s:input = fnc."\<CR>"
                                  let before = substitute(fnc,'($','','').'('
                                  let after  = ')'
                                  if newchar ==# 'F'
                                    let before .= ' '
                                    let after = ' ' . after
                                  endif
                                endif
                              elseif newchar ==# "\<C-F>"
                                let fnc = input('function: ')
                                let s:input = fnc."\<CR>"
                                let before = '('.fnc.' '
                                let after = ')'
                              elseif idx >= 0
                                let spc = (idx % 3) == 1 ? " " : ""
                                let idx = idx / 3 * 3
                                let before = strpart(pairs,idx+1,1) . spc
                                let after  = spc . strpart(pairs,idx+2,1)
                              elseif newchar == "\<C-[>" || newchar == "\<C-]>"
                                let before = "{\n\t"
                                let after  = "\n}"
                              elseif newchar !~ '\a'
    2              0.000010     let before = newchar
    2              0.000009     let after  = newchar
    2              0.000005   else
                                let before = ''
                                let after  = ''
                              endif
    2              0.000046   let after  = substitute(after ,'\n','\n'.initspaces,'g')
    2              0.000014   if type ==# 'V' || (a:special && type ==# "v")
    2              0.000037     let before = substitute(before,' \+$','','')
    2              0.000032     let after  = substitute(after ,'^ \+','','')
    2              0.000021     if after !~ '^\n'
    2              0.000014       let after  = initspaces.after
    2              0.000005     endif
    2              0.000061     if keeper !~ '\n$' && after !~ '^\n'
                                  let keeper .= "\n"
                                elseif keeper =~ '\n$' && after =~ '^\n'
                                  let after = strpart(after,1)
                                endif
    2              0.000022     if before !~ '\n\s*$'
    2              0.000014       let before .= "\n"
    2              0.000008       if a:special
    2              0.000012         let before .= "\t"
    2              0.000004       endif
    2              0.000003     endif
    2              0.000003   endif
    2              0.000009   if type ==# 'V'
    2              0.000020     let before = initspaces.before
    2              0.000004   endif
    2              0.000032   if before =~ '\n\s*\%$'
    2              0.000009     if type ==# 'v'
                                  let keeper = initspaces.keeper
                                endif
    2              0.000048     let padding = matchstr(before,'\n\zs\s\+\%$')
    2              0.000048     let before  = substitute(before,'\n\s\+\%$','\n','')
    2   0.000774   0.000060     let keeper = s:fixindent(keeper,padding)
    2              0.000003   endif
    2              0.000008   if type ==# 'V'
    2              0.000026     let keeper = before.keeper.after
    2              0.000006   elseif type =~ "^\<C-V>"
                                " Really we should be iterating over the buffer
                                let repl = substitute(before,'[\\~]','\\&','g').'\1'.substitute(after,'[\\~]','\\&','g')
                                let repl = substitute(repl,'\n',' ','g')
                                let keeper = substitute(keeper."\n",'\(.\{-\}\)\(\n\)',repl.'\n','g')
                                let keeper = substitute(keeper,'\n\%$','','')
                              else
                                let keeper = before.extraspace.keeper.extraspace.after
                              endif
    2              0.000009   return keeper

FUNCTION  <SNR>80_search()
Called 46 times
Total time:   0.000470
 Self time:   0.000470

count  total (s)   self (s)
   46              0.000054     if g:clever_f_across_no_line
   46              0.000397         return search(a:pat, a:flag, line('.'))
                                else
                                    return search(a:pat, a:flag)
                                endif

FUNCTION  ale_linters#vim#vint#Handle()
Called 8 times
Total time:   0.007277
 Self time:   0.002343

count  total (s)   self (s)
    8   0.005083   0.000150     let l:loclist = ale#handlers#gcc#HandleGCCFormat(a:buffer, a:lines)
                            
   16              0.000049     for l:item in l:loclist
    8              0.000025         let l:match = []
                            
   40              0.000120         for l:regex in s:word_regex_list
   32              0.001054             let l:match = matchlist(l:item.text, l:regex)
                            
   32              0.000144             if !empty(l:match)
                                            let l:item.end_col = l:item.col + len(l:match[1]) - 1
                                            break
                                        endif
   32              0.000053         endfor
    8              0.000012     endfor
                            
    8              0.000020     return l:loclist

FUNCTION  <SNR>76_CloseWindowIfNeeded()
Called 8 times
Total time:   0.001380
 Self time:   0.000232

count  total (s)   self (s)
    8   0.001342   0.000194     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    8              0.000019         return
                                endif
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                        endif
                                    else
                                        let l:win_id = s:BufWinId(a:buffer)
                            
                                        if g:ale_set_loclist && empty(getloclist(l:win_id))
                                            lclose
                                        endif
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 193 times
Total time:   0.023266
 Self time:   0.014264

count  total (s)   self (s)
  193              0.000865     if !g:ale_echo_cursor
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  193              0.001308     if mode() isnot# 'n'
   59              0.000080         return
                                endif
                            
  134   0.003712   0.001533     call s:StopCursorTimer()
                            
  134              0.001871     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
  134              0.000496     if l:pos != s:last_pos
  130   0.008642   0.001820         let l:delay = ale#Var(bufnr(''), 'echo_delay')
                            
  130              0.000483         let s:last_pos = l:pos
  130              0.001530         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
  130              0.000153     endif

FUNCTION  <SNR>75_UpdateLineNumbers()
Called 8 times
Total time:   0.000904
 Self time:   0.000904

count  total (s)   self (s)
    8              0.000030     let l:line_map = {}
    8              0.000045     let l:line_numbers_changed = 0
                            
   15              0.000080     for [l:line, l:sign_id, l:name] in a:current_sign_list
    7              0.000066         let l:line_map[l:sign_id] = l:line
    7              0.000012     endfor
                            
   16              0.000051     for l:item in a:loclist
    8              0.000031         if l:item.bufnr == a:buffer
    8              0.000082             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
    8              0.000030             if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
    8              0.000011         endif
    8              0.000011     endfor
                            
                                " When the line numbers change, sort the list again
    8              0.000024     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif

FUNCTION  <SNR>54_parse_command()
Called 62 times
Total time:   0.062337
 Self time:   0.007802

count  total (s)   self (s)
   62   0.055861   0.001325   let a:cmdl.cmd.name = s:get_command(a:cmdl.string)
   62              0.001967   if a:cmdl.cmd.name =~# '\v^%(g%[lobal]\!=|v%[global])$'
                                let a:cmdl.cmd.args = s:parse_global(a:cmdl)
                              elseif a:cmdl.cmd.name =~# '\v^%(s%[ubstitute]|sm%[agic]|sno%[magic])$'
                                let a:cmdl.cmd.args = s:parse_substitute(a:cmdl)
                              elseif a:cmdl.cmd.name =~# '\v^%(sor%[t]\!=)$'
                                let a:cmdl.cmd.args = s:parse_sort(a:cmdl)
                              endif

FUNCTION  ale#sign#ReadSigns()
Called 8 times
Total time:   0.000460
 Self time:   0.000460

count  total (s)   self (s)
    8              0.000056     redir => l:output
    8              0.000187        silent execute 'sign place buffer=' . a:buffer
    8              0.000056     redir end
                            
    8              0.000138     return split(l:output, "\n")

FUNCTION  <SNR>74_IsHeaderFile()
Called 8 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
    8              0.000126     return a:filename =~? '\v\.(h|hpp)$'

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   21   3.061603   0.000866  <SNR>63_InvokeChain()
   21   3.050905   0.010212  <SNR>63_RunJob()
   21   2.760919   2.759911  ale#job#Start()
   21   1.676476   0.004060  <SNR>67_VimCloseCallback()
   28   1.669251   0.003776  <SNR>63_HandleExit()
   11   1.649359   0.002377  ale#Lint()
   11   1.635183   0.002576  ale#engine#RunLinters()
   11   1.629324   0.000797  <SNR>63_RunLinter()
   62   0.347842   0.088792  traces#init()
   46   0.303206   0.298383  clever_f#find_with()
   62   0.222148   0.010024  <SNR>54_evaluate_cmdl()
    8   0.217822   0.001195  ale#engine#HandleLoclist()
    8   0.197890   0.001787  ale#engine#SetResults()
   21   0.182987   0.010947  <SNR>63_CreateTemporaryFileForJob()
   10   0.171361             ale#util#Writefile()
   21   0.124047   0.002200  <SNR>67_VimExitCallback()
   95   0.108949   0.062671  <SNR>54_parse_range()
    8   0.103119   0.102929  ale#engine#RemoveManagedFiles()
   21   0.092797   0.003670  ale#command#FormatCommand()
   10   0.088667   0.088218  <SNR>66_TemporaryFilename()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   21   2.760919   2.759911  ale#job#Start()
   46   0.303206   0.298383  clever_f#find_with()
   10              0.171361  ale#util#Writefile()
    8   0.103119   0.102929  ale#engine#RemoveManagedFiles()
   62   0.347842   0.088792  traces#init()
   10   0.088667   0.088218  <SNR>66_TemporaryFilename()
    8   0.086312   0.078601  <SNR>22_PrintMatches()
    8   0.085513   0.074509  ale#sign#SetSigns()
   95   0.108949   0.062671  <SNR>54_parse_range()
   62   0.054536   0.050772  <SNR>54_get_command()
  210              0.037446  <SNR>41_Highlight_Matching_Pair()
   66              0.035492  <SNR>54_spec_to_abs()
   62   0.065571   0.030080  <SNR>54_evaluate_range()
  605              0.023552  <SNR>54_trim()
   62              0.023045  <SNR>54_skip_modifiers()
  161   0.027706   0.021409  ale#ShouldDoNothing()
   42              0.016996  GetVimIndentIntern()
    8   0.021961   0.015932  <SNR>76_SetListsImpl()
  260              0.014599  ale#Var()
  193   0.023266   0.014264  ale#cursor#EchoCursorWarningWithDelay()

